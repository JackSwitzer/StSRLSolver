<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STS Oracle</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            /* Lighter theme */
            --bg-dark: #1a1520;
            --bg-panel: #252030;
            --bg-card: #302840;
            --bg-hover: #3a3350;
            --border: #4a4060;
            --border-light: #5a5070;

            --text: #e8e4f0;
            --text-dim: #a8a0b8;
            --text-muted: #787090;

            --blood: #cc4444;
            --crimson: #e05555;
            --ember: #ff6b5b;

            --gold: #e8c44a;
            --gilt: #f5dca0;
            --brass: #b8a060;

            --jade: #40a070;
            --emerald: #50c888;

            --sapphire: #5080c0;
            --azure: #70a8e0;

            --amethyst: #8855aa;
            --violet: #a878d0;

            --font-display: 'Cinzel', serif;
            --font-body: 'Crimson Text', serif;
            --font-mono: 'JetBrains Mono', monospace;

            /* Spacing scale */
            --space-xs: 4px;
            --space-sm: 6px;
            --space-md: 10px;
            --space-lg: 14px;
            --space-xl: 20px;

            /* Fixed widths for alignment */
            --floor-width: 26px;
            --icon-size: 20px;
            --stats-width: 90px;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--font-body);
            background: var(--bg-dark);
            color: var(--text);
            font-size: 14px;
            line-height: 1.4;
        }

        /* Layout */
        .app {
            display: grid;
            grid-template-rows: auto auto 1fr;
            height: 100vh;
        }

        /* === TOP BAR === */
        .top-bar {
            background: var(--bg-panel);
            border-bottom: 2px solid var(--gold);
            padding: var(--space-sm) var(--space-lg);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-lg);
            position: relative;
            z-index: 10;
        }

        .left-stats {
            display: flex;
            align-items: center;
            gap: var(--space-lg);
        }

        .seed {
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--gold);
            letter-spacing: 1px;
        }

        .floor-act {
            display: flex;
            align-items: baseline;
            gap: var(--space-sm);
        }

        .floor-num {
            font-family: var(--font-display);
            font-size: 20px;
            font-weight: 700;
            color: var(--text);
        }

        .act-badge {
            font-family: var(--font-display);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-dim);
            padding: 2px 8px;
            border: 1px solid var(--border);
            background: var(--bg-card);
        }

        /* HP Bar */
        .hp-container {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .hp-bar-wrap {
            width: 120px;
            height: 16px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 2px;
            overflow: hidden;
        }

        .hp-bar {
            height: 100%;
            background: linear-gradient(180deg, var(--crimson) 0%, var(--blood) 100%);
            transition: width 0.5s ease;
        }

        .hp-text {
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--ember);
            font-weight: 500;
            min-width: 50px;
        }

        /* Gold */
        .gold-display {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
        }

        .gold-icon {
            width: 14px;
            height: 14px;
            background: radial-gradient(circle at 30% 30%, var(--gilt), var(--gold));
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(232, 196, 74, 0.4);
        }

        .gold-value {
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--gold);
            font-weight: 500;
        }

        /* RNG Accuracy */
        .rng-accuracy {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            padding: 2px var(--space-sm);
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 3px;
            cursor: help;
            position: relative;
        }

        .rng-label {
            font-family: var(--font-mono);
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .rng-value {
            font-family: var(--font-mono);
            font-size: 11px;
            font-weight: 600;
        }

        .rng-accuracy.high .rng-value {
            color: var(--emerald);
        }

        .rng-accuracy.medium .rng-value {
            color: var(--gold);
        }

        .rng-accuracy.low .rng-value {
            color: var(--crimson);
        }

        .rng-accuracy.none .rng-value {
            color: var(--text-muted);
        }

        /* RNG Accuracy Tooltip */
        .rng-accuracy:hover::after {
            content: attr(data-details);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-card);
            border: 2px solid var(--gold);
            padding: 10px 14px;
            font-size: 12px;
            font-family: var(--font-mono);
            white-space: pre-line;
            z-index: 1000;
            margin-top: 8px;
            min-width: 200px;
            color: var(--text);
            line-height: 1.6;
            border-radius: 4px;
        }

        /* Right side */
        .right-stats {
            display: flex;
            align-items: center;
            gap: var(--space-md);
        }

        .potions-row {
            display: flex;
            gap: var(--space-xs);
        }

        .potion-slot {
            width: 18px;
            height: 22px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 3px 3px 8px 8px;
            position: relative;
        }

        .potion-slot.filled {
            background: radial-gradient(circle at 50% 40%, var(--azure), var(--sapphire));
            border-color: var(--azure);
            box-shadow: 0 0 6px rgba(112, 168, 224, 0.4);
        }

        .potion-slot.filled.attack { background: radial-gradient(circle at 50% 40%, var(--ember), var(--blood)); border-color: var(--crimson); }
        .potion-slot.filled.skill { background: radial-gradient(circle at 50% 40%, var(--emerald), var(--jade)); border-color: var(--emerald); }
        .potion-slot.filled.power { background: radial-gradient(circle at 50% 40%, var(--violet), var(--amethyst)); border-color: var(--violet); }

        /* Tooltips go DOWN */
        .potion-slot[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-card);
            border: 1px solid var(--gold);
            padding: var(--space-xs) var(--space-sm);
            font-size: 11px;
            white-space: nowrap;
            z-index: 1000;
            margin-top: var(--space-xs);
            color: var(--text);
            border-radius: 3px;
        }

        .relics-row {
            display: flex;
            gap: 3px;
            flex-wrap: wrap;
            flex: 1;
            min-width: 0;
            max-width: 300px;
        }

        .relic-orb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            position: relative;
            cursor: default;
            transition: transform 0.15s;
            border: 1px solid transparent;
        }

        .relic-orb:hover {
            transform: scale(1.3);
            z-index: 100;
        }

        .relic-orb.common { background: radial-gradient(circle at 30% 30%, #999, #666); border-color: #888; }
        .relic-orb.uncommon { background: radial-gradient(circle at 30% 30%, var(--azure), var(--sapphire)); border-color: var(--azure); }
        .relic-orb.rare { background: radial-gradient(circle at 30% 30%, var(--gilt), var(--gold)); border-color: var(--gold); }
        .relic-orb.boss { background: radial-gradient(circle at 30% 30%, var(--violet), var(--amethyst)); border-color: var(--violet); }
        .relic-orb.shop { background: radial-gradient(circle at 30% 30%, var(--emerald), var(--jade)); border-color: var(--emerald); }
        .relic-orb.starter { background: radial-gradient(circle at 30% 30%, #c8b8d8, #9888b8); border-color: #b8a8c8; }

        /* Relic tooltips go DOWN */
        .relic-orb[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-card);
            border: 2px solid var(--gold);
            padding: 6px 10px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            margin-top: 8px;
            color: var(--text);
            border-radius: 4px;
        }

        /* === BOSS BAR (inline in header) === */
        .boss-bar {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            padding: var(--space-xs) var(--space-md);
            background: var(--bg-card);
            border-bottom: 1px solid var(--amethyst);
            flex-wrap: wrap;
        }

        .boss-bar-acts {
            display: flex;
            gap: var(--space-md);
            align-items: center;
        }

        .boss-act-item {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            font-size: 11px;
        }

        .boss-act-item.past {
            opacity: 0.5;
        }

        .boss-act-item.current {
            color: var(--gold);
        }

        .boss-act-item.future {
            color: var(--text-dim);
        }

        .boss-act-label-inline {
            font-family: var(--font-mono);
            font-size: 9px;
            color: var(--text-muted);
        }

        .boss-act-label-inline.current {
            color: var(--gold);
        }

        .boss-act-name {
            font-family: var(--font-body);
            font-size: 11px;
            color: var(--text);
        }

        .boss-act-name.current {
            color: var(--gold);
            font-weight: 600;
        }

        .boss-act-relics {
            display: flex;
            gap: 2px;
        }

        .boss-relic-mini {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, var(--violet), var(--amethyst));
            cursor: default;
            position: relative;
        }

        .boss-relic-mini[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-card);
            border: 1px solid var(--gold);
            padding: var(--space-xs) var(--space-sm);
            font-size: 10px;
            white-space: nowrap;
            z-index: 1000;
            margin-top: var(--space-xs);
            color: var(--text);
            border-radius: 3px;
        }

        .boss-separator-bar {
            color: var(--text-muted);
            margin: 0 2px;
        }

        /* === MAIN CONTENT === */
        .main-content {
            display: grid;
            grid-template-columns: 38% 62%;
            gap: 0;
            height: 100%;
            overflow: hidden;
        }

        /* === LEFT: NEXT OPTIONS (Map + Predictions) === */
        .left-column {
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            padding: var(--space-md);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
        }

        /* Legacy map-column for compatibility */
        .map-column {
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            padding: var(--space-md);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .map-container {
            flex: 0 0 auto;
            max-height: 280px;
            overflow-y: auto;
        }

        /* Compact map mode for left column */
        .map-section-compact {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: var(--space-sm);
        }

        .map-section-compact .map-grid {
            gap: 2px;
        }

        .map-section-compact .map-node {
            width: 22px;
            height: 22px;
            font-size: 10px;
        }

        .map-section-compact .row-label {
            width: 16px;
            font-size: 8px;
        }

        .map-section-compact .map-nodes {
            gap: 2px;
        }

        .section-title {
            font-family: var(--font-display);
            font-size: 9px;
            letter-spacing: 2px;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: var(--space-sm);
            padding-bottom: var(--space-xs);
            border-bottom: 1px solid var(--border);
        }

        .map-grid {
            display: flex;
            flex-direction: column-reverse;
            gap: 3px;
        }

        .map-row {
            display: flex;
            gap: 3px;
            align-items: center;
        }

        .row-label {
            width: 20px;
            font-family: var(--font-mono);
            font-size: 9px;
            color: var(--text-muted);
            text-align: right;
        }

        .map-nodes {
            display: flex;
            gap: 3px;
        }

        .map-node {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 13px;
            font-weight: 600;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease, transform 0.15s ease;
            position: relative;
            border: 2px solid transparent;
        }

        .map-node:not(.empty):hover {
            transform: scale(1.1);
            z-index: 20;
        }

        .map-node:not(.empty):active {
            transform: scale(0.95);
        }

        .map-node.empty {
            width: 14px;
            background: transparent;
            cursor: default;
        }

        .map-node.M { background: #5a3030; color: var(--ember); border-color: #704040; }
        .map-node.E { background: #5a4020; color: #ffa050; border-color: #706030; }
        .map-node.B { background: #6a2020; color: #ff7070; border-color: #803030; }
        .map-node.\$ { background: #4a4a20; color: var(--gold); border-color: #606030; }
        .map-node.R { background: #204a30; color: var(--emerald); border-color: #306040; }
        .map-node.T { background: #4a4020; color: var(--gilt); border-color: #605030; }
        .map-node.\? { background: #3a3060; color: var(--violet); border-color: #504080; }

        .map-node.current {
            box-shadow: 0 0 15px var(--gold);
            border-color: var(--gold) !important;
            animation: pulse-gold 2s ease-in-out infinite;
        }

        .map-node.accessible {
            box-shadow: 0 0 12px var(--emerald);
            border-color: var(--emerald) !important;
            animation: pulse-green 1.5s ease-in-out infinite;
        }

        .map-node.visited {
            opacity: 0.4;
        }

        @keyframes pulse-gold {
            0%, 100% { box-shadow: 0 0 12px var(--gold); }
            50% { box-shadow: 0 0 22px var(--gold); }
        }

        @keyframes pulse-green {
            0%, 100% { box-shadow: 0 0 10px var(--emerald); }
            50% { box-shadow: 0 0 18px var(--emerald); }
        }

        /* Map tooltip */
        /* Map node tooltip - now goes DOWN */
        .map-node:not(.empty):not(.selected):hover::after {
            content: attr(data-info);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-card);
            border: 2px solid var(--gold);
            padding: 10px 14px;
            font-size: 12px;
            font-family: var(--font-body);
            white-space: pre-line;
            z-index: 1000;
            margin-top: 8px;
            min-width: 180px;
            color: var(--text);
            line-height: 1.6;
            border-radius: 4px;
        }

        /* Selected node styling */
        .map-node.selected {
            border-color: var(--gold) !important;
            box-shadow: 0 0 20px var(--gold), inset 0 0 8px rgba(232, 196, 74, 0.3) !important;
            transform: scale(1.15);
            z-index: 50;
        }

        /* Path highlight on hover */
        .map-node.path-highlight {
            box-shadow: 0 0 12px var(--azure);
            border-color: var(--azure) !important;
        }

        .map-node.path-highlight::before {
            content: '';
            position: absolute;
            inset: -4px;
            border: 2px dashed var(--azure);
            border-radius: 7px;
            animation: path-pulse 1s ease-in-out infinite;
        }

        @keyframes path-pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* === NODE DETAIL PANEL === */
        .node-detail-panel {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 6px;
            margin-top: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
            max-height: 0;
            opacity: 0;
        }

        .node-detail-panel.visible {
            max-height: 600px;
            opacity: 1;
        }

        .node-detail-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 14px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
        }

        .node-detail-icon {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 20px;
            font-weight: 700;
            border-radius: 6px;
        }

        .node-detail-icon.M { background: #5a3030; color: var(--ember); }
        .node-detail-icon.E { background: #5a4020; color: #ffa050; }
        .node-detail-icon.B { background: #6a2020; color: #ff7070; }
        .node-detail-icon.\$ { background: #4a4a20; color: var(--gold); }
        .node-detail-icon.R { background: #204a30; color: var(--emerald); }
        .node-detail-icon.T { background: #4a4020; color: var(--gilt); }
        .node-detail-icon.\? { background: #3a3060; color: var(--violet); }

        .node-detail-title {
            flex: 1;
        }

        .node-detail-name {
            font-family: var(--font-display);
            font-size: 16px;
            color: var(--text);
        }

        .node-detail-coords {
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .node-detail-close {
            width: 24px;
            height: 24px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-dim);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.2s;
        }

        .node-detail-close:hover {
            background: var(--bg-hover);
            color: var(--text);
            border-color: var(--crimson);
        }

        .node-detail-body {
            padding: 14px;
            max-height: 350px;
            overflow-y: auto;
        }

        .node-detail-section {
            margin-bottom: 14px;
        }

        .node-detail-section:last-child {
            margin-bottom: 0;
        }

        .node-detail-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-muted);
            margin-bottom: 8px;
            font-family: var(--font-display);
        }

        /* Stats row */
        .node-stats-row {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .node-stat {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
        }

        .node-stat-icon {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .node-stat-icon.hp { color: var(--crimson); }
        .node-stat-icon.gold { color: var(--gold); }
        .node-stat-icon.relic { color: var(--violet); }
        .node-stat-icon.potion { color: var(--azure); }
        .node-stat-icon.card { color: var(--emerald); }

        .node-stat-value {
            color: var(--text);
        }

        /* Shop items grid */
        .shop-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .shop-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: var(--bg-panel);
            border-radius: 4px;
            font-size: 12px;
        }

        .shop-item-name {
            flex: 1;
            color: var(--text);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .shop-item-price {
            color: var(--gold);
            font-family: var(--font-mono);
            font-size: 11px;
        }

        .shop-item.on-sale .shop-item-price {
            color: var(--emerald);
        }

        .shop-item.on-sale::before {
            content: 'SALE';
            font-size: 8px;
            padding: 2px 4px;
            background: var(--emerald);
            color: var(--bg-dark);
            border-radius: 2px;
            font-weight: 600;
        }

        /* Event choices list */
        .event-choices {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .event-choice {
            padding: 8px 12px;
            background: var(--bg-panel);
            border-radius: 4px;
            font-size: 12px;
            border-left: 3px solid var(--violet);
        }

        .event-choice-num {
            font-family: var(--font-mono);
            color: var(--text-muted);
            margin-right: 8px;
        }

        .event-choice-text {
            color: var(--text);
        }

        /* Rest options */
        .rest-options {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .rest-option {
            padding: 8px 14px;
            background: var(--bg-panel);
            border-radius: 4px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .rest-option-icon {
            font-size: 14px;
        }

        .rest-option.heal .rest-option-icon { color: var(--crimson); }
        .rest-option.upgrade .rest-option-icon { color: var(--emerald); }
        .rest-option.lift .rest-option-icon { color: var(--gold); }
        .rest-option.dig .rest-option-icon { color: var(--brass); }
        .rest-option.recall .rest-option-icon { color: var(--violet); }
        .rest-option.toke .rest-option-icon { color: var(--azure); }

        /* Attack pattern display */
        .attack-pattern {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .attack-move {
            padding: 4px 8px;
            background: var(--bg-panel);
            border-radius: 3px;
            font-size: 11px;
            font-family: var(--font-mono);
        }

        .attack-move.attack { border-left: 2px solid var(--crimson); }
        .attack-move.defend { border-left: 2px solid var(--azure); }
        .attack-move.buff { border-left: 2px solid var(--gold); }
        .attack-move.debuff { border-left: 2px solid var(--violet); }

        /* Emerald key indicator */
        .map-node.has-key::after {
            content: '';
            position: absolute;
            top: -4px;
            right: -4px;
            width: 8px;
            height: 8px;
            background: var(--emerald);
            border-radius: 50%;
            box-shadow: 0 0 6px var(--emerald);
        }

        /* Map legend */
        .map-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px 0;
            border-top: 1px solid var(--border);
            margin-top: auto;
        }

        .map-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            color: var(--text-muted);
        }

        .map-legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }

        /* Smooth scroll for detail panel */
        .node-detail-body::-webkit-scrollbar {
            width: 4px;
        }

        .node-detail-body::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* === MIDDLE: PREDICTIONS === */
        .predictions-column {
            background: var(--bg-dark);
            padding: 8px 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .boss-section {
            background: var(--bg-panel);
            border: 2px solid var(--amethyst);
            border-radius: 4px;
            padding: 8px 10px;
        }

        .boss-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .boss-name {
            font-family: var(--font-display);
            font-size: 14px;
            color: var(--text);
        }

        .boss-hp {
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--text-dim);
        }

        .boss-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 4px;
        }

        .boss-chip {
            font-family: var(--font-body);
            font-size: 11px;
            padding: 2px 8px;
            background: linear-gradient(135deg, var(--amethyst), #5a3878);
            color: var(--text);
            border-radius: 3px;
        }

        .boss-act-relics {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            margin-top: 2px;
            margin-left: 50px;
        }

        .boss-relic-chip {
            font-family: var(--font-body);
            font-size: 9px;
            padding: 1px 5px;
            background: linear-gradient(135deg, #3a5a3a, #2a4a2a);
            color: var(--text-dim);
            border-radius: 2px;
        }

        .predicted-bosses {
            display: flex;
            flex-direction: column;
            gap: 3px;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border);
        }

        .predicted-boss-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
        }

        .predicted-boss-row.current {
            font-weight: 600;
        }

        .predicted-boss-row.future {
            color: var(--text-dim);
        }

        .predicted-boss-row.past {
            color: var(--text-muted);
            opacity: 0.6;
        }

        .boss-act-label {
            font-family: var(--font-mono);
            font-size: 10px;
            color: var(--text-muted);
            width: 42px;
        }

        .boss-act-label.current {
            color: var(--gold);
        }

        .boss-names {
            font-family: var(--font-body);
            color: var(--text);
        }

        .boss-names.current {
            color: var(--gold);
        }

        .boss-separator {
            color: var(--text-muted);
            margin: 0 4px;
        }

        .predicted-boss-row[data-tooltip] {
            cursor: help;
            position: relative;
        }

        .predicted-boss-row[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50px;
            background: var(--bg-card);
            border: 2px solid var(--gold);
            padding: 6px 10px;
            font-size: 12px;
            font-weight: normal;
            white-space: nowrap;
            z-index: 1000;
            margin-top: 4px;
            color: var(--text);
            border-radius: 4px;
        }

        .card-reward-section {
            margin-top: 8px;
            padding-top: 6px;
            border-top: 1px solid var(--border);
        }

        /* === NEOW SECTION === */
        .neow-section {
            background: var(--bg-panel);
            border: 2px solid var(--violet);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .neow-title {
            font-family: var(--font-display);
            font-size: 14px;
            letter-spacing: 2px;
            color: var(--violet);
            text-transform: uppercase;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
            text-align: center;
        }

        .neow-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .neow-option {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 10px 12px;
            transition: all 0.2s;
            cursor: default;
        }

        .neow-option:hover {
            border-color: var(--violet);
            background: var(--bg-hover);
        }

        .neow-option.blessing {
            border-left: 3px solid var(--emerald);
        }

        .neow-option.drawback {
            border-left: 3px solid var(--gold);
        }

        .neow-option.boss_swap {
            border-left: 3px solid var(--amethyst);
        }

        .neow-slot {
            font-family: var(--font-mono);
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }

        .neow-name {
            font-family: var(--font-body);
            font-size: 14px;
            color: var(--text);
            font-weight: 500;
        }

        .neow-drawback {
            font-size: 12px;
            color: var(--crimson);
            margin-top: 4px;
            padding-left: 8px;
            border-left: 2px solid var(--crimson);
        }

        .neow-category {
            font-family: var(--font-mono);
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 4px;
        }

        .prediction-cards {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .pred-card {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
            transition: border-color 0.2s;
        }

        .pred-card:hover {
            border-color: var(--border-light);
        }

        .pred-card.M { border-left: 3px solid var(--crimson); }
        .pred-card.E { border-left: 3px solid #ffa050; }
        .pred-card.B { border-left: 3px solid #ff5050; }
        .pred-card.\$ { border-left: 3px solid var(--gold); }
        .pred-card.R { border-left: 3px solid var(--emerald); }
        .pred-card.T { border-left: 3px solid var(--gilt); }
        .pred-card.\? { border-left: 3px solid var(--violet); }

        .pred-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: var(--bg-card);
        }

        .pred-icon {
            width: 26px;
            height: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 13px;
            font-weight: 700;
            border-radius: 4px;
        }

        .pred-icon.M { background: #5a3030; color: var(--ember); }
        .pred-icon.E { background: #5a4020; color: #ffa050; }
        .pred-icon.B { background: #6a2020; color: #ff7070; }
        .pred-icon.\$ { background: #4a4a20; color: var(--gold); }
        .pred-icon.R { background: #204a30; color: var(--emerald); }
        .pred-icon.T { background: #4a4020; color: var(--gilt); }
        .pred-icon.\? { background: #3a3060; color: var(--violet); }

        .pred-title { flex: 1; }

        .pred-name {
            font-family: var(--font-display);
            font-size: 13px;
            color: var(--text);
        }

        .pred-sub {
            font-size: 11px;
            color: var(--text-dim);
            margin-top: 1px;
        }

        .pred-coords {
            font-family: var(--font-mono);
            font-size: 10px;
            color: var(--text-muted);
        }

        .pred-body {
            padding: 6px 10px;
        }

        .pred-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .card-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .card-chip {
            font-family: var(--font-body);
            font-size: 11px;
            padding: 2px 8px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 3px;
        }

        .card-chip.upgraded {
            color: var(--emerald);
            border-color: var(--jade);
            background: rgba(64, 160, 112, 0.15);
        }

        .card-chip.rare {
            color: var(--gold);
            border-color: var(--brass);
            background: rgba(232, 196, 74, 0.15);
        }

        .card-chip.common {
            color: var(--text-dim);
            border-color: var(--border);
        }

        .card-chip.uncommon {
            color: var(--slate);
            border-color: var(--slate);
            background: rgba(128, 144, 160, 0.15);
        }

        .card-chip.on-sale {
            color: var(--emerald);
            border-color: var(--jade);
            background: rgba(64, 160, 112, 0.2);
        }

        .shop-item.unaffordable {
            opacity: 0.5;
        }

        .shop-item.unaffordable .shop-item-price {
            color: var(--crimson);
        }

        .shop-item-name.common {
            color: var(--text-dim);
        }

        .shop-item-name.uncommon {
            color: var(--slate);
        }

        .shop-item-name.rare {
            color: var(--gold);
        }

        .pred-info {
            font-size: 11px;
            color: var(--text-dim);
            font-style: italic;
        }

        .burning-badge {
            display: inline-block;
            font-size: 9px;
            font-weight: 700;
            padding: 1px 5px;
            margin-left: 6px;
            background: linear-gradient(135deg, #ff6b35, #ff4444);
            color: #fff;
            border-radius: 3px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            vertical-align: middle;
            animation: burning-pulse 1.5s ease-in-out infinite;
        }

        @keyframes burning-pulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 4px rgba(255, 107, 53, 0.5); }
            50% { opacity: 0.85; box-shadow: 0 0 8px rgba(255, 68, 68, 0.7); }
        }

        .event-options {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .event-option {
            font-size: 11px;
            color: var(--text-dim);
            padding: 2px 6px;
            background: var(--bg-card);
            border-radius: 3px;
            border-left: 2px solid var(--violet);
        }

        /* === RIGHT: RUN HISTORY (62% width) === */
        .path-column {
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            padding: var(--space-sm) var(--space-md);
            overflow-y: auto;
        }

        /* Alias for clarity */
        .history-column {
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            padding: var(--space-sm) var(--space-md);
            overflow-y: auto;
        }

        .path-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
            padding-bottom: var(--space-xs);
            border-bottom: 1px solid var(--border);
        }

        .path-toggle {
            font-family: var(--font-mono);
            font-size: 9px;
            padding: 2px var(--space-sm);
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-dim);
            cursor: pointer;
            border-radius: 3px;
        }

        .path-toggle:hover {
            background: var(--bg-hover);
            color: var(--text);
        }

        .path-toggle.active {
            background: var(--amethyst);
            border-color: var(--violet);
            color: var(--text);
        }

        /* Act sections */
        .path-act {
            margin-bottom: var(--space-sm);
        }

        .path-act-header {
            font-family: var(--font-display);
            font-size: 10px;
            letter-spacing: 1px;
            color: var(--text-muted);
            text-transform: uppercase;
            padding: var(--space-xs) var(--space-sm);
            border-bottom: 2px solid var(--border);
            margin-bottom: var(--space-xs);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            background: var(--bg-card);
            border-radius: 3px 3px 0 0;
        }

        .path-act-header.act-1 { border-color: var(--jade); background: rgba(64, 160, 112, 0.08); }
        .path-act-header.act-2 { border-color: var(--sapphire); background: rgba(80, 128, 192, 0.08); }
        .path-act-header.act-3 { border-color: var(--amethyst); background: rgba(136, 85, 170, 0.08); }
        .path-act-header.act-4 { border-color: var(--crimson); background: rgba(204, 68, 68, 0.08); }

        .path-act-header .act-hp {
            font-family: var(--font-mono);
            font-size: 10px;
            color: var(--crimson);
            margin-left: auto;
        }

        /* Compact grid mode */
        .path-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
        }

        .path-node {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 9px;
            font-weight: 600;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s;
            position: relative;
            border: 1px solid transparent;
        }

        .path-node:hover {
            transform: scale(1.1);
            z-index: 10;
            border-color: var(--gold);
        }

        .path-node.current {
            box-shadow: 0 0 6px var(--gold);
            border-color: var(--gold);
        }

        .path-node.M { background: #5a3030; color: var(--ember); }
        .path-node.E { background: #5a4020; color: #ffa050; }
        .path-node.B { background: #6a2020; color: #ff7070; }
        .path-node.\$ { background: #4a4a20; color: var(--gold); }
        .path-node.R { background: #204a30; color: var(--emerald); }
        .path-node.T { background: #4a4020; color: var(--gilt); }
        .path-node.\? { background: #3a3060; color: var(--violet); }

        /* Floor number badge */
        .path-node::before {
            content: attr(data-floor);
            position: absolute;
            top: -5px;
            right: -3px;
            font-family: var(--font-mono);
            font-size: 7px;
            color: var(--text-muted);
            background: var(--bg-panel);
            padding: 0 2px;
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .path-node:hover::before {
            opacity: 1;
        }

        /* Damage indicator */
        .path-node.took-damage::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 4px;
            background: var(--crimson);
            border-radius: 50%;
        }

        /* Card picked indicator */
        .path-node.has-card::before {
            content: attr(data-floor);
            position: absolute;
            top: -6px;
            right: -4px;
            font-family: var(--font-mono);
            font-size: 7px;
            color: var(--emerald);
            background: var(--bg-panel);
            padding: 0 2px;
            border-radius: 2px;
            opacity: 0.8;
        }

        /* List mode */
        .path-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .path-item {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            padding: var(--space-xs) var(--space-sm);
            background: var(--bg-card);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s;
            border-left: 2px solid transparent;
            min-height: 28px;
        }

        .path-item:hover {
            background: var(--bg-hover);
        }

        .path-item.current {
            border-left-color: var(--gold);
            background: rgba(232, 196, 74, 0.08);
        }

        .path-item.M { border-left-color: var(--ember); }
        .path-item.E { border-left-color: #ffa050; }
        .path-item.B { border-left-color: #ff7070; }
        .path-item.\$ { border-left-color: var(--gold); }
        .path-item.R { border-left-color: var(--emerald); }
        .path-item.T { border-left-color: var(--gilt); }
        .path-item.\? { border-left-color: var(--violet); }

        .path-floor {
            font-family: var(--font-mono);
            font-size: 10px;
            color: var(--text-muted);
            width: var(--floor-width);
            min-width: var(--floor-width);
            text-align: right;
            flex-shrink: 0;
        }

        .path-icon {
            width: var(--icon-size);
            height: var(--icon-size);
            min-width: var(--icon-size);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 9px;
            font-weight: 600;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .path-icon.M { background: #5a3030; color: var(--ember); }
        .path-icon.E { background: #5a4020; color: #ffa050; }
        .path-icon.B { background: #6a2020; color: #ff7070; }
        .path-icon.\$ { background: #4a4a20; color: var(--gold); }
        .path-icon.R { background: #204a30; color: var(--emerald); }
        .path-icon.T { background: #4a4020; color: var(--gilt); }
        .path-icon.\? { background: #3a3060; color: var(--violet); }

        .path-stats {
            display: flex;
            gap: var(--space-sm);
            margin-left: auto;
            font-family: var(--font-mono);
            font-size: 9px;
            flex-shrink: 0;
            min-width: var(--stats-width);
            justify-content: flex-end;
        }

        .path-stats .hp-change {
            color: var(--crimson);
            min-width: 36px;
            text-align: right;
        }

        .path-stats .hp-change.heal {
            color: var(--emerald);
        }

        .path-stats .gold-change {
            color: var(--gold);
            min-width: 36px;
            text-align: right;
        }

        .path-stats .gold-change.negative {
            color: var(--brass);
        }

        /* Expanded floor detail */
        .path-detail {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            margin: 4px 0;
            overflow: hidden;
            max-height: 0;
            opacity: 0;
            transition: all 0.2s;
        }

        .path-detail.expanded {
            max-height: 400px;
            opacity: 1;
            padding: 8px;
        }

        .path-detail-row {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            padding: 3px 0;
        }

        .path-detail-label {
            color: var(--text-muted);
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 50px;
        }

        .path-detail-value {
            color: var(--text);
        }

        /* Card choices in detail */
        .path-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 4px;
        }

        .path-card {
            font-size: 10px;
            padding: 2px 6px;
            background: var(--bg-panel);
            border-radius: 3px;
            color: var(--text-dim);
        }

        .path-card.picked {
            background: var(--jade);
            color: var(--text);
            font-weight: 500;
        }

        .path-card.rare {
            background: var(--brass);
            color: var(--bg-dark);
        }

        .path-card.picked.rare {
            background: var(--gold);
        }

        /* Boss divider */
        .path-boss-divider {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 0;
            margin: 4px 0;
        }

        .path-boss-divider::before,
        .path-boss-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--crimson);
        }

        .path-boss-name {
            font-family: var(--font-display);
            font-size: 10px;
            color: var(--crimson);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Path timeline (for compatibility) */
        .path-timeline {
            display: flex;
            flex-direction: column;
            gap: 3px;
            position: relative;
        }

        /* Additional path indicators */
        .path-node.got-relic::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            width: 6px;
            height: 6px;
            background: var(--violet);
            border-radius: 50%;
            box-shadow: 0 0 4px var(--violet);
        }

        .path-node.got-potion::after {
            content: '';
            position: absolute;
            bottom: -2px;
            right: -2px;
            width: 5px;
            height: 5px;
            background: var(--azure);
            border-radius: 50%;
        }

        /* Tooltip for path nodes */
        .path-node-tooltip {
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 8px;
            background: var(--bg-card);
            border: 1px solid var(--gold);
            border-radius: 4px;
            padding: 8px 10px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .path-node:hover .path-node-tooltip {
            opacity: 1;
        }

        .path-node-tooltip .tt-floor {
            font-family: var(--font-mono);
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .path-node-tooltip .tt-room {
            color: var(--text);
            font-weight: 500;
        }

        .path-node-tooltip .tt-hp {
            color: var(--crimson);
            margin-top: 4px;
        }

        .path-node-tooltip .tt-gold {
            color: var(--gold);
        }

        /* Scrollbar for path column */
        .path-column::-webkit-scrollbar {
            width: 4px;
        }

        .path-column::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .path-column::-webkit-scrollbar-thumb:hover {
            background: var(--border-light);
        }

        /* Card choice list in path - vertical layout */
        .path-card-choices {
            display: flex;
            flex-direction: column;
            gap: 1px;
            margin-top: 1px;
            margin-left: calc(var(--floor-width) + var(--icon-size) + var(--space-sm) * 2);
            padding-left: var(--space-sm);
            border-left: 1px solid var(--border);
        }

        .card-choice-row {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            font-family: var(--font-mono);
            font-size: 9px;
            line-height: 1.3;
        }

        .card-choice-icon {
            width: 10px;
            text-align: center;
            flex-shrink: 0;
        }

        .card-choice-icon.picked {
            color: var(--emerald);
        }

        .card-choice-icon.skipped {
            color: var(--text-muted);
            opacity: 0.5;
        }

        .card-choice-name {
            white-space: nowrap;
        }

        .card-choice-name.picked {
            color: var(--emerald);
            font-weight: 500;
        }

        .card-choice-name.picked.upgraded {
            color: var(--jade);
        }

        .card-choice-name.skipped {
            color: var(--text-muted);
            opacity: 0.6;
        }

        .card-choice-name.skip-all {
            color: var(--text-muted);
            font-style: italic;
            opacity: 0.6;
        }

        /* Campfire choice styling (vertical layout) */
        .card-choice-icon.campfire-rest {
            color: var(--blood);
        }

        .card-choice-icon.campfire-upgrade {
            color: var(--sapphire);
        }

        .campfire-action {
            font-family: var(--font-mono);
            font-size: 9px;
        }

        .campfire-action.REST {
            color: var(--blood);
        }

        .campfire-action.SMITH {
            color: var(--sapphire);
        }

        .campfire-action.LIFT {
            color: var(--brass);
        }

        .campfire-action.DIG {
            color: var(--amethyst);
        }

        .campfire-action.RECALL {
            color: var(--violet);
        }

        .campfire-action.TOKE {
            color: var(--text-muted);
        }

        /* Floor wrapper for grouping path-item with its choices */
        .path-floor-wrapper {
            display: flex;
            flex-direction: column;
        }

        /* Card choices always visible now - no hover needed */

        .path-floor-wrapper:hover .expand-hint {
            opacity: 1;
        }

        /* Expand indicator for path items with choices */
        .path-item.has-choices {
            cursor: pointer;
        }

        .path-item.has-choices .expand-hint {
            font-size: 8px;
            color: var(--text-muted);
            margin-left: auto;
            opacity: 0.5;
        }

        /* Encounter name in path */
        .path-encounter {
            font-size: 10px;
            color: var(--text-dim);
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .path-encounter.elite {
            color: #ffa050;
            font-weight: 600;
        }

        .path-encounter.event {
            color: var(--violet);
            font-style: italic;
        }

        /* Connection indicator */
        .conn-badge {
            position: fixed;
            bottom: var(--space-sm);
            right: var(--space-sm);
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            padding: var(--space-xs) var(--space-md);
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            font-family: var(--font-mono);
            font-size: 10px;
            z-index: 100;
        }

        .conn-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--crimson);
        }

        .conn-badge.live .conn-dot {
            background: var(--emerald);
            box-shadow: 0 0 6px var(--emerald);
        }

        .refresh-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 12px;
            padding: 2px var(--space-xs);
            margin-left: 2px;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .refresh-btn:hover {
            background: var(--bg-hover);
            color: var(--gold);
        }

        .refresh-btn:active {
            transform: rotate(180deg);
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--border-light); }

        .empty-state {
            color: var(--text-muted);
            font-style: italic;
            padding: var(--space-md);
            text-align: center;
            font-size: 12px;
        }

        /* === PATH PLANNING === */
        .map-node.planned {
            box-shadow: 0 0 12px #00d4d4 !important;
            border-color: #00d4d4 !important;
            animation: pulse-cyan 1.5s ease-in-out infinite !important;
        }

        .map-node.planned-start {
            box-shadow: 0 0 15px #00ffff !important;
            border-color: #00ffff !important;
        }

        .map-node.planned-next {
            box-shadow: 0 0 8px rgba(0, 212, 212, 0.5);
            border-color: rgba(0, 212, 212, 0.6) !important;
            cursor: pointer;
        }

        .map-node.planned-next:hover {
            box-shadow: 0 0 14px #00d4d4;
            border-color: #00d4d4 !important;
        }

        @keyframes pulse-cyan {
            0%, 100% { box-shadow: 0 0 10px #00d4d4; }
            50% { box-shadow: 0 0 18px #00ffff; }
        }

        /* Path planning controls */
        .path-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
            align-items: center;
        }

        .path-btn {
            font-family: var(--font-mono);
            font-size: 11px;
            padding: 6px 12px;
            background: var(--bg-card);
            border: 2px solid var(--border);
            color: var(--text);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .path-btn:hover {
            border-color: var(--border-light);
            background: var(--bg-hover);
        }

        .path-btn.active {
            border-color: #00d4d4;
            color: #00ffff;
            background: rgba(0, 212, 212, 0.15);
        }

        .path-btn.clear {
            border-color: var(--crimson);
            color: var(--ember);
        }

        .path-btn.clear:hover {
            background: rgba(224, 85, 85, 0.2);
        }

        .path-btn.save {
            border-color: var(--jade);
            color: var(--emerald);
        }

        .path-btn.save:hover {
            background: rgba(80, 200, 136, 0.2);
        }

        /* Path planning mode indicator */
        .planning-indicator {
            display: none;
            align-items: center;
            gap: 6px;
            font-family: var(--font-mono);
            font-size: 11px;
            color: #00ffff;
            padding: 4px 8px;
            background: rgba(0, 212, 212, 0.15);
            border: 1px solid #00d4d4;
            border-radius: 4px;
        }

        .planning-indicator.active {
            display: flex;
        }

        .planning-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #00ffff;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Planned path display in path column */
        .planned-path-section {
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid #00d4d4;
        }

        .planned-path-section .section-title {
            color: #00d4d4;
            border-bottom-color: #00d4d4;
        }

        .planned-path-timeline {
            display: flex;
            flex-direction: column;
            gap: 3px;
            position: relative;
        }

        .planned-path-timeline::before {
            content: '';
            position: absolute;
            left: 16px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #00d4d4;
        }

        .planned-path-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 3px 0;
            cursor: pointer;
            transition: all 0.2s;
        }

        .planned-path-item:hover {
            background: rgba(0, 212, 212, 0.1);
            margin: 0 -8px;
            padding: 3px 8px;
            border-radius: 4px;
        }

        .planned-path-icon {
            width: 22px;
            height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 11px;
            font-weight: 600;
            border-radius: 4px;
            z-index: 1;
            border: 2px solid #00d4d4;
        }

        .planned-path-icon.M { background: #5a3030; color: var(--ember); }
        .planned-path-icon.E { background: #5a4020; color: #ffa050; }
        .planned-path-icon.B { background: #6a2020; color: #ff7070; }
        .planned-path-icon.\$ { background: #4a4a20; color: var(--gold); }
        .planned-path-icon.R { background: #204a30; color: var(--emerald); }
        .planned-path-icon.T { background: #4a4020; color: var(--gilt); }
        .planned-path-icon.\? { background: #3a3060; color: var(--violet); }

        /* === CUMULATIVE PREVIEW PANEL === */
        .preview-column {
            background: var(--bg-panel);
            border-left: 1px solid #00d4d4;
            padding: 12px;
            overflow-y: auto;
            display: none;
            flex-direction: column;
            gap: 12px;
            min-width: 280px;
        }

        .preview-column.visible {
            display: flex;
        }

        .preview-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .preview-title {
            font-family: var(--font-display);
            font-size: 11px;
            letter-spacing: 3px;
            color: #00d4d4;
            text-transform: uppercase;
        }

        .preview-close {
            width: 20px;
            height: 20px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-dim);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .preview-close:hover {
            border-color: var(--crimson);
            color: var(--ember);
        }

        .preview-path-nodes {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
        }

        .preview-path-node {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 11px;
            font-weight: 600;
            border-radius: 4px;
            border: 2px solid #00d4d4;
        }

        .preview-path-node.M { background: #5a3030; color: var(--ember); }
        .preview-path-node.E { background: #5a4020; color: #ffa050; }
        .preview-path-node.\$ { background: #4a4a20; color: var(--gold); }
        .preview-path-node.R { background: #204a30; color: var(--emerald); }
        .preview-path-node.T { background: #4a4020; color: var(--gilt); }
        .preview-path-node.\? { background: #3a3060; color: var(--violet); }
        .preview-path-node.B { background: #6a2020; color: #ff7070; }

        .preview-section {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px;
        }

        .preview-section-title {
            font-family: var(--font-display);
            font-size: 10px;
            letter-spacing: 2px;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .preview-stat {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
        }

        .preview-stat:last-child {
            margin-bottom: 0;
        }

        .preview-stat-label {
            font-size: 13px;
            color: var(--text-dim);
        }

        .preview-stat-value {
            font-family: var(--font-mono);
            font-size: 13px;
        }

        .preview-stat-value.positive {
            color: var(--emerald);
        }

        .preview-stat-value.negative {
            color: var(--ember);
        }

        .preview-stat-value.neutral {
            color: var(--gold);
        }

        .preview-cards-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            max-height: 150px;
            overflow-y: auto;
        }

        .preview-card-chip {
            font-family: var(--font-body);
            font-size: 12px;
            padding: 4px 8px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 3px;
        }

        .preview-card-chip.upgraded {
            color: var(--emerald);
            border-color: var(--jade);
        }

        .preview-card-chip.rare {
            color: var(--gold);
            border-color: var(--brass);
        }

        .preview-relics-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .preview-relic-chip {
            font-family: var(--font-body);
            font-size: 12px;
            padding: 4px 8px;
            background: var(--bg-panel);
            border: 1px solid var(--amethyst);
            color: var(--violet);
            border-radius: 3px;
        }

        .preview-potions-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .preview-potion-chip {
            font-family: var(--font-body);
            font-size: 12px;
            padding: 4px 8px;
            background: var(--bg-panel);
            border: 1px solid var(--azure);
            color: var(--azure);
            border-radius: 3px;
        }

        /* === PATH TREE VISUALIZATION === */
        .path-tree-container {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: var(--space-sm);
            overflow-x: auto;
        }

        .path-tree-floor {
            display: flex;
            align-items: flex-start;
            gap: var(--space-sm);
            margin-bottom: var(--space-sm);
            position: relative;
        }

        .path-tree-floor:last-child {
            margin-bottom: 0;
        }

        .path-tree-floor-label {
            font-family: var(--font-mono);
            font-size: 9px;
            color: var(--text-muted);
            min-width: 40px;
            padding-top: var(--space-xs);
        }

        .path-tree-nodes {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-xs);
            flex: 1;
        }

        .path-tree-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: var(--space-xs) var(--space-sm);
            min-width: 70px;
            cursor: pointer;
            transition: all 0.15s;
            position: relative;
        }

        .path-tree-node:hover {
            border-color: var(--gold);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .path-tree-node.M { border-left: 3px solid var(--crimson); }
        .path-tree-node.E { border-left: 3px solid #ffa050; }
        .path-tree-node.B { border-left: 3px solid #ff5050; }
        .path-tree-node.\$ { border-left: 3px solid var(--gold); }
        .path-tree-node.R { border-left: 3px solid var(--emerald); }
        .path-tree-node.T { border-left: 3px solid var(--gilt); }
        .path-tree-node.\? { border-left: 3px solid var(--violet); }

        .path-tree-node-header {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            width: 100%;
        }

        .path-tree-node-icon {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 10px;
            font-weight: 700;
            border-radius: 3px;
        }

        .path-tree-node-icon.M { background: #5a3030; color: var(--ember); }
        .path-tree-node-icon.E { background: #5a4020; color: #ffa050; }
        .path-tree-node-icon.B { background: #6a2020; color: #ff7070; }
        .path-tree-node-icon.\$ { background: #4a4a20; color: var(--gold); }
        .path-tree-node-icon.R { background: #204a30; color: var(--emerald); }
        .path-tree-node-icon.T { background: #4a4020; color: var(--gilt); }
        .path-tree-node-icon.\? { background: #3a3060; color: var(--violet); }

        .path-tree-node-name {
            font-family: var(--font-body);
            font-size: 10px;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 60px;
        }

        .path-tree-node-coords {
            font-family: var(--font-mono);
            font-size: 8px;
            color: var(--text-muted);
        }

        .path-tree-node-details {
            font-size: 9px;
            color: var(--text-dim);
            margin-top: var(--space-xs);
            width: 100%;
        }

        .path-tree-node-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            margin-top: var(--space-xs);
        }

        .path-tree-card-chip {
            font-size: 8px;
            padding: 1px 3px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 2px;
            color: var(--text-dim);
        }

        .path-tree-card-chip.rare {
            color: var(--gold);
            border-color: var(--brass);
        }

        .path-tree-card-chip.upgraded {
            color: var(--emerald);
            border-color: var(--jade);
        }

        /* Connector lines between floors */
        .path-tree-connectors {
            display: flex;
            gap: 6px;
            margin-left: 58px;
            margin-bottom: 4px;
            height: 16px;
            position: relative;
        }

        .path-tree-connector {
            font-family: var(--font-mono);
            font-size: 14px;
            color: var(--text-muted);
            line-height: 1;
        }

        /* Empty state */
        .path-tree-empty {
            color: var(--text-muted);
            font-style: italic;
            text-align: center;
            padding: 16px;
        }

        /* Tooltip for path tree nodes */
        .path-tree-node[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-card);
            border: 2px solid var(--gold);
            padding: 8px 12px;
            font-size: 11px;
            white-space: pre-line;
            z-index: 1000;
            margin-bottom: 8px;
            min-width: 150px;
            max-width: 250px;
            color: var(--text);
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        /* === SAVED PATHS === */
        .saved-paths-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
        }

        .saved-path-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .saved-path-item:hover {
            border-color: var(--border-light);
            background: var(--bg-hover);
        }

        .saved-path-item.comparing {
            border-color: var(--gold);
            background: rgba(232, 196, 74, 0.1);
        }

        .saved-path-info {
            flex: 1;
        }

        .saved-path-name {
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--text);
        }

        .saved-path-summary {
            font-size: 11px;
            color: var(--text-dim);
            margin-top: 2px;
        }

        .saved-path-actions {
            display: flex;
            gap: 4px;
        }

        .saved-path-btn {
            font-size: 12px;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .saved-path-btn:hover {
            background: var(--bg-hover);
        }

        .saved-path-btn.load:hover {
            color: #00d4d4;
        }

        .saved-path-btn.delete:hover {
            color: var(--crimson);
        }

        /* Comparison panel */
        .comparison-panel {
            display: none;
            margin-top: 12px;
            padding: 10px;
            background: var(--bg-card);
            border: 1px solid var(--gold);
            border-radius: 6px;
        }

        .comparison-panel.visible {
            display: block;
        }

        .comparison-title {
            font-family: var(--font-display);
            font-size: 10px;
            letter-spacing: 2px;
            color: var(--gold);
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .comparison-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .comparison-label {
            flex: 1;
            color: var(--text-dim);
        }

        .comparison-current {
            font-family: var(--font-mono);
            color: #00ffff;
            min-width: 50px;
            text-align: right;
        }

        .comparison-saved {
            font-family: var(--font-mono);
            color: var(--gold);
            min-width: 50px;
            text-align: right;
        }

        .comparison-diff {
            font-family: var(--font-mono);
            min-width: 50px;
            text-align: right;
        }

        .comparison-diff.better {
            color: var(--emerald);
        }

        .comparison-diff.worse {
            color: var(--ember);
        }

        /* Updated grid layout to include preview panel */
        .main-content.with-preview {
            grid-template-columns: 40% 35% 25%;
        }
    </style>
</head>
<body>
    <div class="app">
        <!-- HEADER ROW 1: Core Stats -->
        <div class="top-bar">
            <div class="left-stats">
                <span class="seed" id="seed">---</span>
                <div class="floor-act">
                    <span class="floor-num" id="floor">0</span>
                    <span class="act-badge" id="act">Act 1</span>
                </div>
                <div class="hp-container">
                    <div class="hp-bar-wrap">
                        <div class="hp-bar" id="hp-bar" style="width: 100%"></div>
                    </div>
                    <span class="hp-text" id="hp-text">0/0</span>
                </div>
                <div class="gold-display">
                    <div class="gold-icon"></div>
                    <span class="gold-value" id="gold">0</span>
                </div>
                <div class="rng-accuracy" id="rng-accuracy" title="RNG Prediction Accuracy">
                    <span class="rng-label">RNG:</span>
                    <span class="rng-value" id="rng-value">--</span>
                </div>
            </div>
            <div class="right-stats">
                <div class="potions-row" id="potions"></div>
                <div class="relics-row" id="relics"></div>
            </div>
        </div>
        <!-- HEADER ROW 2: Boss Predictions Bar -->
        <div class="boss-bar" id="boss-bar">
            <div class="boss-bar-acts" id="boss-bar-acts">
                <!-- Populated by JS -->
            </div>
        </div>

        <div class="main-content">
            <!-- LEFT COLUMN: Next Options (40%) -->
            <div class="left-column">
                <!-- Compact Map Section -->
                <div class="map-section-compact">
                    <div class="section-title">Map</div>
                    <div class="map-container">
                        <div class="map-grid" id="map"></div>
                    </div>
                    <div class="map-legend">
                        <div class="map-legend-item"><div class="map-legend-dot" style="background:#5a3030;color:var(--ember)">M</div>Monster</div>
                        <div class="map-legend-item"><div class="map-legend-dot" style="background:#5a4020;color:#ffa050">E</div>Elite</div>
                        <div class="map-legend-item"><div class="map-legend-dot" style="background:#204a30;color:var(--emerald)">R</div>Rest</div>
                        <div class="map-legend-item"><div class="map-legend-dot" style="background:#3a3060;color:var(--violet)">?</div>Event</div>
                        <div class="map-legend-item"><div class="map-legend-dot" style="background:#4a4a20;color:var(--gold)">$</div>Shop</div>
                        <div class="map-legend-item"><div class="map-legend-dot" style="background:#4a4020;color:var(--gilt)">T</div>Chest</div>
                    </div>
                </div>

                <!-- Node Detail Panel -->
                <div class="node-detail-panel" id="node-detail-panel">
                    <div class="node-detail-header">
                        <div class="node-detail-icon" id="detail-icon">?</div>
                        <div class="node-detail-title">
                            <div class="node-detail-name" id="detail-name">Select a Node</div>
                            <div class="node-detail-coords" id="detail-coords"></div>
                        </div>
                        <button class="node-detail-close" id="detail-close" title="Close">&times;</button>
                    </div>
                    <div class="node-detail-body" id="detail-body"></div>
                </div>

                <!-- Neow Section (floor 0 only) -->
                <div class="neow-section" id="neow-section" style="display: none;">
                    <div class="neow-title">Neow's Blessing</div>
                    <div class="neow-options" id="neow-options"></div>
                </div>

                <!-- Next Options -->
                <div class="predictions-section" id="predictions-section">
                    <div class="section-title">Next Options</div>
                    <div class="prediction-cards" id="predictions"></div>
                </div>

                <!-- Path Tree Preview -->
                <div class="path-tree-section" style="margin-top: 12px;">
                    <div class="section-title">Path Preview (3 Floors)</div>
                    <div class="path-tree-container" id="path-tree"></div>
                </div>

                <!-- Hidden boss elements for JS compatibility -->
                <div id="boss-section" style="display:none;">
                    <span id="boss-name"></span><span id="boss-hp"></span>
                    <div id="predicted-bosses"></div>
                    <div id="boss-chips"></div><div id="boss-cards"></div>
                </div>
            </div>

            <!-- Hidden elements for JS compatibility -->
            <div id="preview-column" style="display:none;">
                <div class="preview-path-nodes" id="preview-path-nodes"></div>
                <span id="preview-hp">--</span>
                <span id="preview-gold">--</span>
                <span id="preview-fights">--</span>
                <span id="preview-elites">--</span>
                <div id="preview-cards"></div>
                <div id="preview-relics"></div>
                <div id="preview-potions"></div>
                <div id="saved-paths-section"><div id="saved-paths-list"></div></div>
                <div id="comparison-panel">
                    <span id="cmp-hp-current">--</span><span id="cmp-hp-saved">--</span><span id="cmp-hp-diff">--</span>
                    <span id="cmp-gold-current">--</span><span id="cmp-gold-saved">--</span><span id="cmp-gold-diff">--</span>
                    <span id="cmp-cards-current">--</span><span id="cmp-cards-saved">--</span><span id="cmp-cards-diff">--</span>
                </div>
                <button id="preview-close"></button>
            </div>

            <!-- RIGHT COLUMN: Run History (60%) -->
            <div class="path-column">
                <div class="path-header">
                    <div class="section-title" style="margin-bottom: 0; padding-bottom: 0; border-bottom: none;">Run History</div>
                    <button class="path-toggle" id="path-toggle-mode" title="Toggle compact/expanded view">List</button>
                </div>
                <div id="run-history"></div>

                <!-- Planned Path Section -->
                <div class="planned-path-section" id="planned-path-section" style="display: none;">
                    <div class="section-title">Planned Path</div>
                    <div class="path-controls">
                        <button class="path-btn active" id="btn-plan-mode">Plan</button>
                        <button class="path-btn save" id="btn-save-path">Save</button>
                        <button class="path-btn clear" id="btn-clear-path">Clear</button>
                    </div>
                    <div class="planned-path-timeline" id="planned-path"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="conn-badge" id="conn">
        <span class="conn-dot"></span>
        <span id="conn-text">Connecting</span>
        <button class="refresh-btn" onclick="refreshState()" title="Refresh state">&#x21bb;</button>
    </div>

    <script>
        const RELIC_RARITY = {
            'PureWater': 'starter', 'CrackedCore': 'starter', 'BurningBlood': 'starter', 'Ring of the Snake': 'starter',
            'Anchor': 'common', 'Art of War': 'common', 'Bag of Marbles': 'common', 'Blood Vial': 'common',
            'Bronze Scales': 'common', 'Damaru': 'common', 'Happy Flower': 'common', 'Juzu Bracelet': 'common',
            'Lantern': 'common', 'MawBank': 'common', 'Nunchaku': 'common', 'Omamori': 'common',
            'Orichalcum': 'common', 'Pen Nib': 'common', 'Potion Belt': 'common', 'Strawberry': 'common',
            'Boot': 'common', 'Vajra': 'common', 'War Paint': 'common', 'Whetstone': 'common',
            'Dream Catcher': 'common', 'Eternal Feather': 'common',
            'Blue Candle': 'uncommon', 'Bottled Flame': 'uncommon', 'Bottled Lightning': 'uncommon',
            'Frozen Egg': 'uncommon', 'Gremlin Horn': 'uncommon', 'Horn Cleat': 'uncommon',
            'Ink Bottle': 'uncommon', 'Kunai': 'uncommon', 'Letter Opener': 'uncommon',
            'Meat on the Bone': 'uncommon', 'Mercury Hourglass': 'uncommon', 'Molten Egg 2': 'uncommon',
            'Mummified Hand': 'uncommon', 'Ornamental Fan': 'uncommon', 'Paper Phrog': 'uncommon',
            'Pear': 'uncommon', 'Question Card': 'uncommon', 'Self-Forming Clay': 'uncommon',
            'Shuriken': 'uncommon', 'Singing Bowl': 'uncommon', 'Sundial': 'uncommon',
            'Toxic Egg 2': 'uncommon', 'White Beast Statue': 'uncommon', 'Duality': 'uncommon',
            'Teardrop Locket': 'uncommon', 'TeardropLocket': 'uncommon',
            'Bird Faced Urn': 'rare', 'Calipers': 'rare', 'Dead Branch': 'rare', 'Du-Vu Doll': 'rare',
            'Fossilized Helix': 'rare', 'Ginger': 'rare', 'Girya': 'rare', 'Ice Cream': 'rare',
            'Incense Burner': 'rare', 'Lizard Tail': 'rare', 'Mango': 'rare', 'Old Coin': 'rare',
            'Peace Pipe': 'rare', 'Pocketwatch': 'rare', 'Prayer Wheel': 'rare', 'Shovel': 'rare',
            'Stone Calendar': 'rare', 'Thread and Needle': 'rare', 'Torii': 'rare', 'Tungsten Rod': 'rare',
            'Turnip': 'rare', 'Unceasing Top': 'rare', 'WingedGreaves': 'rare', 'Winged Greaves': 'rare',
            'Cloak Clasp': 'rare', 'Golden Eye': 'rare',
            'Astrolabe': 'boss', 'Black Blood': 'boss', 'Black Star': 'boss', 'Busted Crown': 'boss',
            'Calling Bell': 'boss', 'Coffee Dripper': 'boss', 'Cursed Key': 'boss', 'Ectoplasm': 'boss',
            'Empty Cage': 'boss', 'Fusion Hammer': 'boss', 'HolyWater': 'boss', 'Holy Water': 'boss',
            'Hovering Kite': 'boss', 'Inserter': 'boss', 'Mark of Pain': 'boss', 'Nuclear Battery': 'boss',
            'Pandoras Box': 'boss', "Pandora's Box": 'boss', 'Philosophers Stone': 'boss',
            'Ring of the Serpent': 'boss', 'Runic Cube': 'boss', 'Runic Dome': 'boss', 'Runic Pyramid': 'boss',
            'Sacred Bark': 'boss', 'Slavers Collar': 'boss', 'Snecko Eye': 'boss', 'Sozu': 'boss',
            'Tiny House': 'boss', 'Velvet Choker': 'boss', 'Violet Lotus': 'boss',
            'Cauldron': 'shop', 'Chemical X': 'shop', 'ClockworkSouvenir': 'shop', 'Frozen Eye': 'shop',
            'HandDrill': 'shop', "Lee's Waffle": 'shop', 'Membership Card': 'shop', 'Orange Pellets': 'shop',
            'Orrery': 'shop', 'PrismaticShard': 'shop', 'Strange Spoon': 'shop', 'TheAbacus': 'shop',
            'Toolbox': 'shop', 'MealTicket': 'shop', 'Meal Ticket': 'shop',
        };

        const RARE_CARDS = ['Ragnarok', 'Wish', 'Omniscience', 'Blasphemy', 'Devotion', 'Establishment',
            'Judgment', 'Lesson Learned', 'Scrawl', 'Spirit Shield', 'Vault', 'Worship', 'Deva Form',
            'Alpha', 'Master Reality', 'Sands of Time', 'Brilliance', 'Conjure Blade', 'Wheel Kick'];

        const MONSTER_HP = {
            'Cultist': '50-56', 'Jaw Worm': '42-46', 'Blue Slaver': '48-52', 'Red Slaver': '48-52',
            'Looter': '46-50', 'Gremlin Nob': '82-86', 'Lagavulin': '112-116', 'Sentry': '39-45',
            'The Guardian': '240', 'Hexaghost': '264', 'Slime Boss': '150',
            'Chosen': '96-99', 'Byrd': '28-32', 'Spheric Guardian': '20', 'Snecko': '60-64',
            'Snake Plant': '60-64', 'Book of Stabbing': '168', 'Gremlin Leader': '162',
            'The Champ': '440', 'Automaton': '320', 'Collector': '300',
            'Writhing Mass': '175', 'Giant Head': '520', 'Nemesis': '200', 'Reptomancer': '190',
            'Awakened One': '320', 'Time Eater': '480', 'Donu and Deca': '250+250',
            'Centurion and Mystic': '76-80 + 56-60', 'Slavers': '~150 total',
        };

        function getRelicRarity(name) { return RELIC_RARITY[name] || 'common'; }
        function isRareCard(name) { return RARE_CARDS.some(r => name.includes(r)); }

        function updateRngAccuracy(accuracy) {
            const el = document.getElementById('rng-accuracy');
            const valueEl = document.getElementById('rng-value');

            if (!accuracy || accuracy.error || !accuracy.overall) {
                valueEl.textContent = '--';
                el.className = 'rng-accuracy none';
                el.setAttribute('data-details', 'No data available');
                return;
            }

            const overall = accuracy.overall;
            const total = overall.total || 0;
            const correct = overall.correct || 0;
            const ratio = overall.ratio || 0;

            if (total === 0) {
                valueEl.textContent = '--';
                el.className = 'rng-accuracy none';
                el.setAttribute('data-details', 'No predictions yet');
                return;
            }

            // Display percentage with count
            const percentage = Math.round(ratio * 100);
            valueEl.textContent = `${percentage}% (${correct}/${total})`;

            // Color coding based on accuracy
            let colorClass = 'none';
            if (ratio >= 0.9) {
                colorClass = 'high';
            } else if (ratio >= 0.7) {
                colorClass = 'medium';
            } else {
                colorClass = 'low';
            }
            el.className = `rng-accuracy ${colorClass}`;

            // Build tooltip with breakdown
            let details = `Overall: ${percentage}% (${correct}/${total})`;

            if (accuracy.cards && accuracy.cards.total > 0) {
                const cardPct = Math.round(accuracy.cards.ratio * 100);
                details += `\nCards: ${cardPct}% (${accuracy.cards.correct}/${accuracy.cards.total})`;
            }

            if (accuracy.relics && accuracy.relics.total > 0) {
                const relicPct = Math.round(accuracy.relics.ratio * 100);
                details += `\nRelics: ${relicPct}% (${accuracy.relics.correct}/${accuracy.relics.total})`;
            }

            if (accuracy.potions && accuracy.potions.total > 0) {
                const potionPct = Math.round(accuracy.potions.ratio * 100);
                details += `\nPotions: ${potionPct}% (${accuracy.potions.correct}/${accuracy.potions.total})`;
            }

            // Add mismatch info
            if (accuracy.mismatches && accuracy.mismatches.length > 0) {
                const lastMismatch = accuracy.mismatches[accuracy.mismatches.length - 1];
                details += `\n\nLast mismatch: Floor ${lastMismatch.floor}`;
                if (lastMismatch.type === 'card') {
                    if (lastMismatch.missing && lastMismatch.missing.length > 0) {
                        details += `\n  Missing: ${lastMismatch.missing.slice(0, 2).join(', ')}`;
                    }
                }
            }

            el.setAttribute('data-details', details);
        }

        function update(state) {
            if (!state) {
                console.error('[STS] update() called with null state');
                return;
            }
            if (state.error) {
                console.warn('[STS] State has error:', state.error);
                document.getElementById('predictions').innerHTML = `<div class="empty-state">${state.error}</div>`;
                setConnection(false, state.error);
                return;
            }
            console.log('[STS] Updating UI with state for floor', state.run?.floor);

            // Top bar
            document.getElementById('seed').textContent = state.seed?.string || '---';
            document.getElementById('floor').textContent = state.run?.floor || '0';
            document.getElementById('act').textContent = `Act ${state.run?.act || 1}`;

            const hp = state.player?.hp || 0;
            const maxHp = state.player?.max_hp || 1;
            document.getElementById('hp-bar').style.width = `${(hp / maxHp) * 100}%`;
            document.getElementById('hp-text').textContent = `${hp}/${maxHp}`;
            document.getElementById('gold').textContent = state.player?.gold || 0;

            // Potions - A11+ has 2 slots, otherwise 3 slots
            const potions = state.potions || [];
            const ascensionLevel = state.run?.ascension || 0;
            const potionSlots = ascensionLevel >= 11 ? 2 : 3;
            document.getElementById('potions').innerHTML = Array.from({length: potionSlots}, (_, i) => {
                const p = potions[i];
                const isEmpty = !p || p.includes('PotionSlot');
                let typeClass = '';
                if (!isEmpty) {
                    if (p.includes('Fire') || p.includes('Attack') || p.includes('Explosive') || p.includes('Strength')) typeClass = 'attack';
                    else if (p.includes('Block') || p.includes('Dexterity') || p.includes('Speed') || p.includes('Skill')) typeClass = 'skill';
                    else if (p.includes('Regen') || p.includes('Fairy') || p.includes('Fruit')) typeClass = 'power';
                }
                return `<div class="potion-slot ${isEmpty ? '' : 'filled ' + typeClass}" ${!isEmpty ? `data-tooltip="${p}"` : ''}></div>`;
            }).join('');

            // Relics
            document.getElementById('relics').innerHTML = (state.relics || []).map(r =>
                `<div class="relic-orb ${getRelicRarity(r)}" data-tooltip="${r}"></div>`
            ).join('');

            // RNG Accuracy
            updateRngAccuracy(state.rng_accuracy);

            renderMap(state);
            renderBossSection(state);
            renderNeowSection(state);
            renderPredictions(state);
            renderPathTree(state);
            renderPath(state);
        }

        // State for interactive map
        let selectedNode = null;
        let currentMapState = null;

        // Monster attack patterns (simplified summaries)
        const MONSTER_PATTERNS = {
            'Cultist': ['Attack (6dmg)', 'Ritual (+3 str)', 'Repeat'],
            'Jaw Worm': ['Attack (11dmg)', 'Block+Str', 'Attack (7dmg)'],
            'Blue Slaver': ['Attack (12dmg)', 'Weak debuff', 'Attack (12dmg)'],
            'Red Slaver': ['Attack (13dmg)', 'Entangle', 'Attack (13dmg)'],
            'Looter': ['Attack+Steal', 'Attack (10dmg)', 'Escape'],
            'Gremlin Nob': ['Skull Bash', 'Rush (14dmg)', 'Rage on skill'],
            'Lagavulin': ['Debuff (-1 str/dex)', 'Attack (18dmg)', 'Sleep 3 turns'],
            'Sentry': ['Bolt (9dmg)', 'Beam (10dmg)', 'Add Dazed'],
            'The Guardian': ['Phase 1: Attack/Block', 'Mode Shift at HP threshold', 'Phase 2: Spike damage'],
            'Hexaghost': ['Charge up 6 turns', 'Inferno (6x6 dmg)', 'Burns deck'],
            'Slime Boss': ['Attack (35dmg)', 'Split at 50% HP', 'Slime adds'],
            'Chosen': ['Hex debuff', 'Attack (21dmg)', 'Drain'],
            'Byrd': ['Flying (+3 block)', 'Peck (1x5 dmg)', 'Headbutt (3dmg)'],
            'Snecko': ['Confuse debuff', 'Attack (15dmg)', 'Bite (18dmg)'],
            'Book of Stabbing': ['Multi-stab', 'Adds stabs each turn', 'Scaling threat'],
            'Gremlin Leader': ['Summon gremlins', 'Attack (6dmg x3)', 'Buff gremlins'],
            'The Champ': ['Phase 1: Various', 'Execute at 50%', 'Phase 2: Harder hits'],
            'Automaton': ['Boost adds +3 str', 'Compiles', 'Hyperbeam (45dmg)'],
            'Collector': ['Summon torches', 'Fireball (18dmg)', 'Mega debuff'],
            'Giant Head': ['Slow debuff', 'Attack (26dmg)', 'Glare (30dmg)'],
            'Nemesis': ['Scythe (45dmg)', 'Intangible', 'Attack + burns'],
            'Reptomancer': ['Summon daggers', 'Snake Strike', 'Big Bite'],
            'Awakened One': ['Phase 1: Attacks', 'Revive at 0 HP', 'Phase 2: Stronger'],
            'Time Eater': ['Head (26dmg)', 'Ripple (32dmg)', '12 card penalty'],
            'Donu and Deca': ['Circle of Power', 'Deca attacks', 'Heal when pair alive'],
        };

        // Relic drop chances by enemy type
        const RELIC_CHANCES = {
            'elite': '25% relic',
            'boss': '100% boss relic choice',
        };

        // Potion drop chances
        const POTION_CHANCES = {
            'monster': '40% potion',
            'elite': '40% potion',
            'boss': '40% potion',
        };

        function renderMap(state) {
            currentMapState = state;
            const map = state.map || [];
            if (!map.length) {
                document.getElementById('map').innerHTML = '<div class="empty-state">No map</div>';
                return;
            }

            const curX = state.current_position?.x ?? -1;
            const curY = state.current_position?.y ?? -1;
            const accessible = new Set((state.accessible_nodes || []).map(n => `${n.x},${n.y}`));
            const predMap = {};
            (state.node_predictions || []).forEach(p => { predMap[`${p.node.x},${p.node.y}`] = p; });

            const monsters = state.monster_list || [];
            const elites = state.elite_monster_list || [];
            const events = state.event_list || [];
            const pathTaken = state.path_taken || [];
            let monstersUsed = pathTaken.filter(p => p === 'M').length;
            let elitesUsed = pathTaken.filter(p => p === 'E').length;
            let eventsUsed = pathTaken.filter(p => p === '?').length;

            let html = '';
            for (let row = map.length - 1; row >= 0; row--) {
                if (!map[row].some(n => n.room_type)) continue;

                html += `<div class="map-row"><span class="row-label">${row + 1}</span><div class="map-nodes">`;
                for (const node of map[row]) {
                    const rt = node.room_type || '';
                    if (!rt && !node.has_edges) { html += `<div class="map-node empty"></div>`; continue; }

                    const isCur = node.x === curX && row === curY;
                    const isAcc = accessible.has(`${node.x},${row}`);
                    const isVis = row < curY;
                    const isSelected = selectedNode && selectedNode.x === node.x && selectedNode.y === row;

                    let cls = `map-node ${rt}`;
                    if (isCur) cls += ' current';
                    else if (isAcc) cls += ' accessible';
                    if (isVis) cls += ' visited';
                    if (isSelected) cls += ' selected';

                    let info = `${node.room_name || rt} (${node.x}, ${row})`;
                    if (rt === 'M' && !isVis && monsters[monstersUsed]) {
                        const m = monsters[monstersUsed];
                        info += `\n${m}` + (MONSTER_HP[m] ? ` (${MONSTER_HP[m]})` : '');
                    } else if (rt === 'E' && !isVis && elites[elitesUsed]) {
                        const e = elites[elitesUsed];
                        info += `\n${e}` + (MONSTER_HP[e] ? ` (${MONSTER_HP[e]})` : '');
                    } else if (rt === '?' && !isVis && events[eventsUsed]) {
                        info += `\n${events[eventsUsed]}`;
                    }

                    const pred = predMap[`${node.x},${row}`];
                    if (pred?.card_reward?.cards) info += `\nCards: ${pred.card_reward.cards.join(', ')}`;

                    // Store node data for click handler
                    const nodeDataAttr = JSON.stringify({
                        x: node.x,
                        y: row,
                        room_type: rt,
                        room_name: node.room_name,
                        edges: node.edges,
                        has_emerald_key: node.has_emerald_key
                    }).replace(/"/g, '&quot;');

                    html += `<div class="${cls}" data-info="${info.replace(/"/g, '&quot;')}" data-node="${nodeDataAttr}" data-x="${node.x}" data-y="${row}">${rt}</div>`;
                }
                html += '</div></div>';
            }
            document.getElementById('map').innerHTML = html;

            // Add click handlers
            document.querySelectorAll('.map-node:not(.empty)').forEach(el => {
                el.addEventListener('click', handleNodeClick);
                el.addEventListener('mouseenter', handleNodeHover);
                el.addEventListener('mouseleave', handleNodeLeave);
            });

            // Update detail panel if node still selected
            if (selectedNode) {
                // Check if selected node still exists in current map
                const stillExists = map.some(row =>
                    row.some(n => n.x === selectedNode.x && n.room_type === selectedNode.room_type)
                );
                if (stillExists) {
                    updateDetailPanel(state);
                    // Re-add selected class to the node
                    const nodeEl = document.querySelector(`.map-node[data-x="${selectedNode.x}"][data-y="${selectedNode.y}"]`);
                    if (nodeEl) nodeEl.classList.add('selected');
                } else {
                    closeDetailPanel();
                }
            }
        }

        function handleNodeClick(e) {
            const el = e.currentTarget;
            const nodeData = JSON.parse(el.dataset.node);

            // Toggle selection
            if (selectedNode && selectedNode.x === nodeData.x && selectedNode.y === nodeData.y) {
                selectedNode = null;
                closeDetailPanel();
            } else {
                selectedNode = nodeData;
                updateDetailPanel(currentMapState);
            }

            // Update visual selection state
            document.querySelectorAll('.map-node.selected').forEach(n => n.classList.remove('selected'));
            if (selectedNode) {
                el.classList.add('selected');
                document.getElementById('node-detail-panel').classList.add('visible');
            }
        }

        function handleNodeHover(e) {
            const el = e.currentTarget;
            const x = parseInt(el.dataset.x);
            const y = parseInt(el.dataset.y);

            // Highlight path from current position to this node
            highlightPathToNode(x, y);
        }

        function handleNodeLeave() {
            // Clear path highlights
            document.querySelectorAll('.map-node.path-highlight').forEach(n => n.classList.remove('path-highlight'));
        }

        function highlightPathToNode(targetX, targetY) {
            if (!currentMapState) return;

            const map = currentMapState.map;
            const curX = currentMapState.current_position?.x ?? -1;
            const curY = currentMapState.current_position?.y ?? -1;

            // Clear existing highlights
            document.querySelectorAll('.map-node.path-highlight').forEach(n => n.classList.remove('path-highlight'));

            // If target is at or below current position, no path to show
            if (targetY <= curY) return;

            // BFS to find path from current position to target
            const path = findPath(map, curX, curY, targetX, targetY);

            // Highlight path nodes
            path.forEach(({x, y}) => {
                const nodeEl = document.querySelector(`.map-node[data-x="${x}"][data-y="${y}"]`);
                if (nodeEl && !nodeEl.classList.contains('current') && !nodeEl.classList.contains('visited')) {
                    nodeEl.classList.add('path-highlight');
                }
            });
        }

        function findPath(map, startX, startY, targetX, targetY) {
            // Simple BFS pathfinding
            const queue = [{x: startX, y: startY, path: []}];
            const visited = new Set();

            // If starting from floor 0 (before map), start from all row 0 nodes
            if (startY < 0 || startX < 0) {
                queue.length = 0;
                for (const node of map[0]) {
                    if (node.has_edges) {
                        queue.push({x: node.x, y: 0, path: [{x: node.x, y: 0}]});
                    }
                }
            }

            while (queue.length > 0) {
                const {x, y, path} = queue.shift();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                visited.add(key);

                if (x === targetX && y === targetY) {
                    return path;
                }

                // Get edges from this node
                if (y >= 0 && y < map.length) {
                    const node = map[y].find(n => n.x === x);
                    if (node && node.edges) {
                        for (const edge of node.edges) {
                            if (!edge.is_boss) {
                                const newPath = [...path, {x: edge.dst_x, y: edge.dst_y}];
                                queue.push({x: edge.dst_x, y: edge.dst_y, path: newPath});
                            }
                        }
                    }
                }
            }

            return [];
        }

        function closeDetailPanel() {
            selectedNode = null;
            document.getElementById('node-detail-panel').classList.remove('visible');
            document.querySelectorAll('.map-node.selected').forEach(n => n.classList.remove('selected'));
        }

        function updateDetailPanel(state) {
            if (!selectedNode) return;

            const panel = document.getElementById('node-detail-panel');
            const iconEl = document.getElementById('detail-icon');
            const nameEl = document.getElementById('detail-name');
            const coordsEl = document.getElementById('detail-coords');
            const bodyEl = document.getElementById('detail-body');

            const rt = selectedNode.room_type;
            const x = selectedNode.x;
            const y = selectedNode.y;

            // Update header
            iconEl.className = `node-detail-icon ${rt}`;
            iconEl.textContent = rt;
            coordsEl.textContent = `Floor ${y + 1} - Column ${x + 1}`;

            // Get predictions and lists
            const predMap = {};
            (state.node_predictions || []).forEach(p => { predMap[`${p.node.x},${p.node.y}`] = p; });
            const pred = predMap[`${x},${y}`];

            const monsters = state.monster_list || [];
            const elites = state.elite_monster_list || [];
            const events = state.event_list || [];
            const pathTaken = state.path_taken || [];
            const monstersUsed = pathTaken.filter(p => p === 'M').length;
            const elitesUsed = pathTaken.filter(p => p === 'E').length;
            const eventsUsed = pathTaken.filter(p => p === '?').length;
            const relics = state.relics || [];

            // Render content based on room type
            let html = '';

            switch (rt) {
                case 'M':
                    html = renderMonsterDetail(monsters[monstersUsed], pred, 'monster');
                    break;
                case 'E':
                    html = renderMonsterDetail(elites[elitesUsed], pred, 'elite');
                    break;
                case 'B':
                    html = renderBossDetail(state, pred);
                    break;
                case '?':
                    html = renderEventDetail(events[eventsUsed], pred);
                    break;
                case '$':
                    html = renderShopDetail(state, pred);
                    break;
                case 'T':
                    html = renderTreasureDetail(state, pred);
                    break;
                case 'R':
                    html = renderRestDetail(state, relics);
                    break;
                default:
                    html = '<div class="pred-info">Unknown room type</div>';
            }

            bodyEl.innerHTML = html;

            // Update name based on content
            const nameMap = {
                'M': monsters[monstersUsed] || 'Monster',
                'E': elites[elitesUsed] || 'Elite',
                'B': state.boss || 'Boss',
                '?': events[eventsUsed] || 'Unknown Event',
                '$': 'Shop',
                'T': 'Treasure',
                'R': 'Rest Site',
            };
            nameEl.textContent = nameMap[rt] || selectedNode.room_name || rt;

            panel.classList.add('visible');
        }

        function renderMonsterDetail(monsterName, pred, type) {
            if (!monsterName) return '<div class="pred-info">Unknown enemy</div>';

            let html = '';

            // HP Range
            const hpRange = MONSTER_HP[monsterName];
            if (hpRange) {
                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Stats</div>
                        <div class="node-stats-row">
                            <div class="node-stat">
                                <span class="node-stat-icon hp">HP</span>
                                <span class="node-stat-value">${hpRange}</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Attack Pattern
            const pattern = MONSTER_PATTERNS[monsterName];
            if (pattern) {
                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Attack Pattern</div>
                        <div class="attack-pattern">
                            ${pattern.map(move => {
                                let cls = 'attack-move';
                                if (move.toLowerCase().includes('attack') || move.toLowerCase().includes('dmg')) cls += ' attack';
                                else if (move.toLowerCase().includes('block') || move.toLowerCase().includes('defend')) cls += ' defend';
                                else if (move.toLowerCase().includes('buff') || move.toLowerCase().includes('str')) cls += ' buff';
                                else cls += ' debuff';
                                return `<span class="${cls}">${move}</span>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            // Card Reward
            if (pred?.card_reward?.cards) {
                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Card Reward</div>
                        <div class="card-chips">
                            ${pred.card_reward.cards.map(c => {
                                const up = c.endsWith('+');
                                const rare = isRareCard(c.replace('+', ''));
                                return `<span class="card-chip ${up ? 'upgraded' : ''} ${rare ? 'rare' : ''}">${c}</span>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            // Potion Drop Prediction
            if (pred?.potion_drop && !pred.potion_drop.error) {
                const potion = pred.potion_drop;
                if (potion.will_drop) {
                    html += `
                        <div class="node-detail-section">
                            <div class="node-detail-label">Potion Drop</div>
                            <div class="card-chips">
                                <span class="card-chip ${potion.rarity?.toLowerCase() || ''}">${potion.potion_name} (${potion.rarity || 'Unknown'})</span>
                            </div>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="node-detail-section">
                            <div class="node-detail-label">Potion Drop</div>
                            <div class="pred-info">No potion (roll: ${Math.round(potion.drop_roll * 100)}% vs ${Math.round(potion.drop_chance * 100)}% chance)</div>
                        </div>
                    `;
                }
            } else {
                // Fallback to generic drop chances
                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Drop Chances</div>
                        <div class="node-stats-row">
                            <div class="node-stat">
                                <span class="node-stat-icon potion">P</span>
                                <span class="node-stat-value">${POTION_CHANCES[type] || '40% potion'}</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Elite relic chance
            if (type === 'elite') {
                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Relic</div>
                        <div class="node-stats-row">
                            <div class="node-stat">
                                <span class="node-stat-icon relic">R</span>
                                <span class="node-stat-value">${RELIC_CHANCES.elite}</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            return html;
        }

        function renderBossDetail(state, pred) {
            const boss = state.boss || 'Unknown Boss';
            // Use prediction data if available, otherwise fall back to top-level state
            const bossRelics = pred?.boss_relics || state.boss_relics || [];
            const bossCardReward = pred?.card_reward || state.boss_card_reward;

            let html = '';

            // HP
            const hpRange = MONSTER_HP[boss];
            if (hpRange) {
                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Stats</div>
                        <div class="node-stats-row">
                            <div class="node-stat">
                                <span class="node-stat-icon hp">HP</span>
                                <span class="node-stat-value">${hpRange}</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Attack Pattern
            const pattern = MONSTER_PATTERNS[boss];
            if (pattern) {
                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Attack Pattern</div>
                        <div class="attack-pattern">
                            ${pattern.map(move => {
                                let cls = 'attack-move';
                                if (move.toLowerCase().includes('attack') || move.toLowerCase().includes('dmg')) cls += ' attack';
                                else if (move.toLowerCase().includes('block') || move.toLowerCase().includes('phase')) cls += ' defend';
                                else cls += ' buff';
                                return `<span class="${cls}">${move}</span>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            // Boss Relics
            if (bossRelics.length) {
                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Boss Relic Choices</div>
                        <div class="card-chips">
                            ${bossRelics.map(r => `<span class="card-chip rare">${r}</span>`).join('')}
                        </div>
                    </div>
                `;
            }

            // Card Reward
            if (bossCardReward?.cards?.length) {
                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Card Reward</div>
                        <div class="card-chips">
                            ${bossCardReward.cards.map(c => {
                                const up = c.endsWith('+');
                                const rare = isRareCard(c.replace('+', ''));
                                return `<span class="card-chip ${up ? 'upgraded' : ''} ${rare ? 'rare' : ''}">${c}</span>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            return html;
        }

        function renderEventDetail(eventName, pred) {
            let html = '';

            if (eventName) {
                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Predicted Event</div>
                        <div class="event-choices">
                            <div class="event-choice">
                                <span class="event-choice-text">${eventName}</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Show event info if available
            if (pred?.event_info?.possible_events) {
                const events = pred.event_info.possible_events.slice(0, 5);
                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Possible Events (${pred.event_info.total_count} total)</div>
                        <div class="event-choices">
                            ${events.map(ev => `
                                <div class="event-choice">
                                    <span class="event-choice-text">${ev.name}</span>
                                    ${ev.choices?.length ? `
                                        <div style="margin-top: 4px; font-size: 11px; color: var(--text-muted);">
                                            ${ev.choices.map(c => c.description).join(' / ')}
                                        </div>
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            } else {
                html += `
                    <div class="node-detail-section">
                        <div class="pred-info">Event outcomes vary based on your choices and current state.</div>
                    </div>
                `;
            }

            return html;
        }

        function renderShopDetail(state, pred) {
            let html = '';
            const gold = state.player?.gold || 0;

            // Check if we have actual shop inventory prediction
            if (pred?.shop_inventory && !pred.shop_inventory.error) {
                const shop = pred.shop_inventory;

                // Colored Cards (5 cards, one on sale)
                if (shop.colored_cards?.length) {
                    html += `
                        <div class="node-detail-section">
                            <div class="node-detail-label">Cards for Sale</div>
                            <div class="shop-grid">
                                ${shop.colored_cards.map(c => {
                                    const affordable = gold >= c.price;
                                    const rarityClass = c.rarity?.toLowerCase() || '';
                                    return `
                                        <div class="shop-item ${!affordable ? 'unaffordable' : ''} ${c.on_sale ? 'on-sale' : ''}">
                                            <span class="shop-item-name ${rarityClass}">${c.card_name}${c.on_sale ? ' (SALE)' : ''}</span>
                                            <span class="shop-item-price">${c.price}g</span>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }

                // Colorless Cards (2 cards)
                if (shop.colorless_cards?.length) {
                    html += `
                        <div class="node-detail-section">
                            <div class="node-detail-label">Colorless Cards</div>
                            <div class="shop-grid">
                                ${shop.colorless_cards.map(c => {
                                    const affordable = gold >= c.price;
                                    const rarityClass = c.rarity?.toLowerCase() || '';
                                    return `
                                        <div class="shop-item ${!affordable ? 'unaffordable' : ''}">
                                            <span class="shop-item-name ${rarityClass}">${c.card_name}</span>
                                            <span class="shop-item-price">${c.price}g</span>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }

                // Relics (3 relics)
                if (shop.relics?.length) {
                    html += `
                        <div class="node-detail-section">
                            <div class="node-detail-label">Relics</div>
                            <div class="shop-grid">
                                ${shop.relics.map(r => {
                                    const affordable = gold >= r.price;
                                    const tierClass = r.tier?.toLowerCase() || '';
                                    return `
                                        <div class="shop-item ${!affordable ? 'unaffordable' : ''}">
                                            <span class="shop-item-name ${tierClass}">${r.relic_name}</span>
                                            <span class="shop-item-price">${r.price}g</span>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }

                // Potions (3 potions)
                if (shop.potions?.length) {
                    html += `
                        <div class="node-detail-section">
                            <div class="node-detail-label">Potions</div>
                            <div class="shop-grid">
                                ${shop.potions.map(p => {
                                    const affordable = gold >= p.price;
                                    return `
                                        <div class="shop-item ${!affordable ? 'unaffordable' : ''}">
                                            <span class="shop-item-name">${p.potion_name}</span>
                                            <span class="shop-item-price">${p.price}g</span>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }

                // Card Removal
                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Services</div>
                        <div class="shop-grid">
                            <div class="shop-item ${gold < shop.purge_cost ? 'unaffordable' : ''}">
                                <span class="shop-item-name">Card Removal</span>
                                <span class="shop-item-price">${shop.purge_cost}g</span>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // Fallback to generic info if no prediction available
                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Shop Info</div>
                        <div class="pred-info">Shop contains cards, relics, potions, and card removal service.</div>
                    </div>
                `;

                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Available Items</div>
                        <div class="shop-grid">
                            <div class="shop-item">
                                <span class="shop-item-name">5 Colored Cards</span>
                                <span class="shop-item-price">50-150g</span>
                            </div>
                            <div class="shop-item">
                                <span class="shop-item-name">2 Colorless Cards</span>
                                <span class="shop-item-price">60-180g</span>
                            </div>
                            <div class="shop-item">
                                <span class="shop-item-name">3 Relics</span>
                                <span class="shop-item-price">150-300g</span>
                            </div>
                            <div class="shop-item">
                                <span class="shop-item-name">3 Potions</span>
                                <span class="shop-item-price">50-100g</span>
                            </div>
                            <div class="shop-item">
                                <span class="shop-item-name">Card Removal</span>
                                <span class="shop-item-price">75g+</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Current gold
            html += `
                <div class="node-detail-section">
                    <div class="node-stats-row">
                        <div class="node-stat">
                            <span class="node-stat-icon gold">G</span>
                            <span class="node-stat-value">Current Gold: ${gold}</span>
                        </div>
                    </div>
                </div>
            `;

            return html;
        }

        function renderTreasureDetail(state, pred) {
            let html = '';

            // Check if we have actual prediction data
            if (pred?.treasure && !pred.treasure.error) {
                const treasure = pred.treasure;
                const chestTypeDisplay = {
                    'SMALL': 'Small Chest',
                    'MEDIUM': 'Medium Chest',
                    'LARGE': 'Large Chest',
                }[treasure.chest_type] || treasure.chest_type;

                const tierDisplay = {
                    'COMMON': 'Common',
                    'UNCOMMON': 'Uncommon',
                    'RARE': 'Rare',
                }[treasure.relic_tier] || treasure.relic_tier;

                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Chest Type</div>
                        <div class="node-stats-row">
                            <div class="node-stat">
                                <span class="node-stat-icon relic">T</span>
                                <span class="node-stat-value">${chestTypeDisplay}</span>
                            </div>
                        </div>
                    </div>
                `;

                // Exact relic prediction
                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Relic</div>
                        <div class="card-chips">
                            <span class="card-chip ${tierDisplay.toLowerCase()}">${treasure.relic_name} (${tierDisplay})</span>
                        </div>
                    </div>
                `;

                // Gold
                if (treasure.has_gold && treasure.gold_amount > 0) {
                    html += `
                        <div class="node-detail-section">
                            <div class="node-detail-label">Gold</div>
                            <div class="node-stats-row">
                                <div class="node-stat">
                                    <span class="node-stat-icon gold">G</span>
                                    <span class="node-stat-value">${treasure.gold_amount}</span>
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="node-detail-section">
                            <div class="node-detail-label">Gold</div>
                            <div class="pred-info">No gold in this chest</div>
                        </div>
                    `;
                }
            } else {
                // Fallback to generic info if no prediction available
                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Chest Info</div>
                        <div class="pred-info">Contains a relic and possibly gold.</div>
                    </div>
                `;

                // Chest type probabilities
                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Chest Types</div>
                        <div class="shop-grid">
                            <div class="shop-item">
                                <span class="shop-item-name">Small (50%)</span>
                                <span class="shop-item-price">Common relic</span>
                            </div>
                            <div class="shop-item">
                                <span class="shop-item-name">Medium (33%)</span>
                                <span class="shop-item-price">Uncommon relic</span>
                            </div>
                            <div class="shop-item">
                                <span class="shop-item-name">Large (17%)</span>
                                <span class="shop-item-price">Rare relic</span>
                            </div>
                        </div>
                    </div>
                `;

                // Gold chances
                html += `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Gold Bonus</div>
                        <div class="node-stats-row">
                            <div class="node-stat">
                                <span class="node-stat-icon gold">G</span>
                                <span class="node-stat-value">25-75g (35-50% chance)</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            return html;
        }

        function renderRestDetail(state, relics) {
            let html = `
                <div class="node-detail-section">
                    <div class="node-detail-label">Rest Options</div>
                    <div class="rest-options">
            `;

            // Base options
            html += `
                <div class="rest-option heal">
                    <span class="rest-option-icon">+</span>
                    <span>Rest: Heal 30% HP</span>
                </div>
                <div class="rest-option upgrade">
                    <span class="rest-option-icon">^</span>
                    <span>Smith: Upgrade a card</span>
                </div>
            `;

            // Relic-based options
            if (relics.includes('Girya')) {
                html += `
                    <div class="rest-option lift">
                        <span class="rest-option-icon">*</span>
                        <span>Lift: +1 Strength (max 3)</span>
                    </div>
                `;
            }

            if (relics.includes('Shovel')) {
                html += `
                    <div class="rest-option dig">
                        <span class="rest-option-icon">!</span>
                        <span>Dig: Get a relic</span>
                    </div>
                `;
            }

            if (relics.includes('Peace Pipe')) {
                html += `
                    <div class="rest-option toke">
                        <span class="rest-option-icon">~</span>
                        <span>Toke: Remove a card</span>
                    </div>
                `;
            }

            if (relics.includes('Dream Catcher')) {
                html += `
                    <div class="rest-option recall">
                        <span class="rest-option-icon">Z</span>
                        <span>Dream: Card reward after rest</span>
                    </div>
                `;
            }

            // Check for Coffee Dripper (cannot rest)
            if (relics.includes('Coffee Dripper')) {
                html += `
                    <div class="rest-option" style="border-left: 2px solid var(--crimson); padding-left: 8px;">
                        <span class="rest-option-icon" style="color: var(--crimson);">X</span>
                        <span style="color: var(--text-muted);">Cannot Rest (Coffee Dripper)</span>
                    </div>
                `;
            }

            // Check for Fusion Hammer (cannot smith)
            if (relics.includes('Fusion Hammer')) {
                html += `
                    <div class="rest-option" style="border-left: 2px solid var(--crimson); padding-left: 8px;">
                        <span class="rest-option-icon" style="color: var(--crimson);">X</span>
                        <span style="color: var(--text-muted);">Cannot Smith (Fusion Hammer)</span>
                    </div>
                `;
            }

            html += `</div></div>`;

            // Current HP for context
            const hp = state.player?.hp || 0;
            const maxHp = state.player?.max_hp || 1;
            const healAmount = Math.floor(maxHp * 0.3);
            html += `
                <div class="node-detail-section">
                    <div class="node-stats-row">
                        <div class="node-stat">
                            <span class="node-stat-icon hp">HP</span>
                            <span class="node-stat-value">${hp}/${maxHp} (+${healAmount} from rest)</span>
                        </div>
                    </div>
                </div>
            `;

            return html;
        }

        // Close button handler - use event delegation to avoid duplicate listeners
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('detail-close').addEventListener('click', closeDetailPanel);

            // Close panel on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && selectedNode) {
                    closeDetailPanel();
                }
            });
        });

        function renderBossSection(state) {
            const boss = state.boss || 'Unknown Boss';
            const bossRelics = state.boss_relics || [];
            const bossCardReward = state.boss_card_reward;
            const currentAct = state.run?.act || 1;
            const ascension = state.run?.ascension || 0;
            const predictedBosses = state.predicted_bosses || {};
            const bossRelicsPerAct = state.boss_relics_per_act || {};

            document.getElementById('boss-name').textContent = boss;
            document.getElementById('boss-hp').textContent = MONSTER_HP[boss] ? `HP: ${MONSTER_HP[boss]}` : '';

            // Render inline boss bar in header
            const bossBarEl = document.getElementById('boss-bar-acts');
            if (bossBarEl) {
                let barHtml = '';
                for (let act = 1; act <= 3; act++) {
                    let bosses = predictedBosses[String(act)] || predictedBosses[act] || [];
                    // Filter out null/None values
                    bosses = bosses.filter(b => b && b !== 'None' && b !== 'null');
                    if (bosses.length === 0) bosses = ['?'];

                    const actRelics = bossRelicsPerAct[String(act)] || bossRelicsPerAct[act] || [];
                    const isCurrent = act === currentAct;
                    const isPast = act < currentAct;

                    let statusClass = isPast ? 'past' : (isCurrent ? 'current' : 'future');
                    const bossName = bosses[0] || '?';

                    // Build relic orbs
                    const relicOrbs = actRelics.slice(0, 3).map(r =>
                        `<div class="boss-relic-mini" data-tooltip="${r}"></div>`
                    ).join('');

                    barHtml += `
                        <div class="boss-act-item ${statusClass}">
                            <span class="boss-act-label-inline ${isCurrent ? 'current' : ''}">A${act}:</span>
                            <span class="boss-act-name ${isCurrent ? 'current' : ''}">${bossName}</span>
                            ${relicOrbs ? `<div class="boss-act-relics">${relicOrbs}</div>` : ''}
                        </div>
                    `;
                }
                bossBarEl.innerHTML = barHtml;
            }

            // Render predicted bosses for all acts with boss relics
            const predictedBossesEl = document.getElementById('predicted-bosses');
            if (predictedBossesEl) {
                let bossesHtml = '';
                for (let act = 1; act <= 3; act++) {
                    // JSON keys are strings, so use String(act) for lookup
                    let bosses = predictedBosses[String(act)] || predictedBosses[act] || [];
                    // Filter out null/None values
                    bosses = bosses.filter(b => b && b !== 'None' && b !== 'null');
                    if (bosses.length === 0) bosses = ['Unknown'];
                    const actRelics = bossRelicsPerAct[String(act)] || bossRelicsPerAct[act] || [];
                    const isCurrent = act === currentAct;
                    const isPast = act < currentAct;
                    const isFuture = act > currentAct;

                    let statusClass = 'future';
                    if (isCurrent) statusClass = 'current';
                    if (isPast) statusClass = 'past';

                    const bossNames = bosses.join('<span class="boss-separator"> + </span>');
                    const actLabel = `Act ${act}:`;

                    // Build tooltip with HP info
                    const hpInfo = bosses.map(b => {
                        const hp = MONSTER_HP[b];
                        return hp ? `${b}: ${hp} HP` : b;
                    }).join(' / ');

                    // Format relics display
                    const relicsDisplay = actRelics.length > 0
                        ? actRelics.map(r => `<span class="boss-relic-chip">${r}</span>`).join('')
                        : '';

                    bossesHtml += `
                        <div class="predicted-boss-row ${statusClass}" data-tooltip="${hpInfo}">
                            <span class="boss-act-label ${isCurrent ? 'current' : ''}">${actLabel}</span>
                            <span class="boss-names ${isCurrent ? 'current' : ''}">${bossNames}</span>
                            ${relicsDisplay ? `<div class="boss-act-relics">${relicsDisplay}</div>` : ''}
                        </div>
                    `;
                }
                predictedBossesEl.innerHTML = bossesHtml;
            }

            document.getElementById('boss-chips').innerHTML = bossRelics.length
                ? bossRelics.map(r => `<span class="boss-chip">${r}</span>`).join('')
                : '<span class="empty-state">None predicted</span>';

            // Boss card reward - display predicted cards from server
            if (bossCardReward?.cards?.length) {
                document.getElementById('boss-cards').innerHTML = bossCardReward.cards.map(c => {
                    const up = c.endsWith('+');
                    const rare = isRareCard(c.replace('+', ''));
                    return `<span class="card-chip ${up ? 'upgraded' : ''} ${rare ? 'rare' : ''}">${c}</span>`;
                }).join('');
            } else {
                document.getElementById('boss-cards').innerHTML = '<span class="empty-state">Not yet predicted</span>';
            }
        }

        function renderPredictions(state) {
            const preds = state.node_predictions || [];
            const accessibleNodes = state.accessible_nodes || [];

            if (!preds.length && !accessibleNodes.length) {
                document.getElementById('predictions').innerHTML = '<div class="empty-state">No accessible nodes</div>';
                return;
            }

            const monsters = state.monster_list || [];
            const elites = state.elite_monster_list || [];
            const events = state.event_list || [];
            const pathTaken = state.path_taken || [];
            const ascension = state.run?.ascension || 0;

            // Count encounters used so far
            const monstersUsed = pathTaken.filter(p => p === 'M').length;
            const elitesUsed = pathTaken.filter(p => p === 'E').length;
            const eventsUsed = pathTaken.filter(p => p === '?').length;

            // Burning elite detection: On A17+, 2nd+ elite in each act has +25% HP, +50% damage
            const elitesKilledThisAct = elitesUsed;
            const isBurningEliteEnabled = ascension >= 17;

            // Build prediction map for quick lookup
            const predMap = {};
            preds.forEach(p => { predMap[`${p.node.x},${p.node.y}`] = p; });

            // Use accessible_nodes as primary source if available, else use preds
            const nodesToRender = accessibleNodes.length > 0 ? accessibleNodes : preds.map(p => p.node);

            // Track encounter indices for multiple same-type nodes
            const encounterIndices = { M: monstersUsed, E: elitesUsed, '?': eventsUsed };

            document.getElementById('predictions').innerHTML = nodesToRender.map((nodeData) => {
                const n = nodeData.node || nodeData;
                const p = predMap[`${n.x},${n.y}`] || {};
                const rt = n.room_type || '?';
                let name = n.room_name || 'Unknown';
                let sub = '';
                let body = '';
                let badges = '';

                // Determine encounter name and details based on room type
                if (rt === 'M') {
                    const idx = encounterIndices.M;
                    name = monsters[idx] || 'Monster';
                    sub = MONSTER_HP[name] ? `HP: ${MONSTER_HP[name]}` : '';
                    encounterIndices.M++;
                } else if (rt === 'E') {
                    const idx = encounterIndices.E;
                    name = elites[idx] || 'Elite';
                    const baseHp = MONSTER_HP[name];
                    const willBeBurning = isBurningEliteEnabled && elitesKilledThisAct >= 1;
                    if (willBeBurning) {
                        badges = ' <span class="burning-badge">BURNING</span>';
                        if (baseHp) {
                            const hpParts = baseHp.split('-');
                            if (hpParts.length === 2) {
                                const lowHp = Math.floor(parseInt(hpParts[0]) * 1.25);
                                const highHp = Math.floor(parseInt(hpParts[1]) * 1.25);
                                sub = `HP: ${lowHp}-${highHp} (+25%)`;
                            } else {
                                const hp = Math.floor(parseInt(baseHp) * 1.25);
                                sub = `HP: ${hp} (+25%)`;
                            }
                        }
                        sub += ' | +50% DMG';
                    } else {
                        sub = baseHp ? `HP: ${baseHp}` : '';
                    }
                    encounterIndices.E++;
                } else if (rt === '?') {
                    const idx = encounterIndices['?'];
                    name = events[idx] || 'Unknown Event';
                    sub = 'Event';
                    encounterIndices['?']++;
                } else if (rt === 'R') {
                    name = 'Campfire';
                    sub = 'Rest or Upgrade';
                } else if (rt === '$') {
                    name = 'Shop';
                    sub = 'Buy cards, relics, remove';
                } else if (rt === 'T') {
                    name = 'Treasure';
                    sub = 'Relic chest';
                } else if (rt === 'B') {
                    name = 'Boss';
                    sub = '';
                }

                // Card reward prediction for M and E nodes
                if (p.card_reward?.cards) {
                    body += `<div class="pred-label">Card Reward</div>`;
                    body += `<div class="card-chips">${p.card_reward.cards.map(c => {
                        const up = c.endsWith('+');
                        const rare = isRareCard(c.replace('+', ''));
                        return `<span class="card-chip ${up ? 'upgraded' : ''} ${rare ? 'rare' : ''}">${c}</span>`;
                    }).join('')}</div>`;
                }

                // Potion drop prediction for combat nodes
                if (p.potion_drop && !p.potion_drop.error) {
                    if (p.potion_drop.will_drop) {
                        body += `<div class="pred-label" style="margin-top:6px">Potion Drop</div>`;
                        body += `<div class="card-chips"><span class="card-chip ${p.potion_drop.rarity?.toLowerCase() || ''}">${p.potion_drop.potion_name}</span></div>`;
                    }
                }

                if (p.boss_relics?.length) {
                    body += `<div class="pred-label" style="margin-top:6px">Boss Relics</div>`;
                    body += `<div class="card-chips">${p.boss_relics.map(r => `<span class="card-chip rare">${r}</span>`).join('')}</div>`;
                }

                // Treasure chest prediction
                if (p.treasure && !p.treasure.error) {
                    const t = p.treasure;
                    const chestType = {'SMALL': 'Small', 'MEDIUM': 'Medium', 'LARGE': 'Large'}[t.chest_type] || t.chest_type;
                    const tier = {'COMMON': 'Common', 'UNCOMMON': 'Uncommon', 'RARE': 'Rare'}[t.relic_tier] || t.relic_tier;
                    body += `<div class="pred-label">${chestType} Chest</div>`;
                    body += `<div class="card-chips"><span class="card-chip ${tier?.toLowerCase() || ''}">${t.relic_name} (${tier})</span></div>`;
                    if (t.has_gold && t.gold_amount > 0) {
                        body += `<div class="pred-info" style="margin-top:4px">+${t.gold_amount} gold</div>`;
                    }
                }

                // Shop inventory prediction
                if (p.shop_inventory && !p.shop_inventory.error) {
                    const shop = p.shop_inventory;
                    if (shop.colored_cards?.length) {
                        body += `<div class="pred-label">Cards</div>`;
                        body += `<div class="card-chips">${shop.colored_cards.map(c =>
                            `<span class="card-chip ${c.rarity?.toLowerCase() || ''} ${c.on_sale ? 'on-sale' : ''}">${c.card_name} ${c.price}g${c.on_sale ? ' SALE' : ''}</span>`
                        ).join('')}</div>`;
                    }
                    if (shop.relics?.length) {
                        body += `<div class="pred-label" style="margin-top:6px">Relics</div>`;
                        body += `<div class="card-chips">${shop.relics.map(r =>
                            `<span class="card-chip ${r.tier?.toLowerCase() || ''}">${r.relic_name} ${r.price}g</span>`
                        ).join('')}</div>`;
                    }
                }

                // Event info if available
                if (p.event_info && !p.event_info.error) {
                    const evt = p.event_info;
                    if (evt.options?.length) {
                        body += `<div class="pred-label" style="margin-top:6px">Options</div>`;
                        body += `<div class="event-options">${evt.options.map(o =>
                            `<div class="event-option">${o.name || o}</div>`
                        ).join('')}</div>`;
                    }
                }

                // Default info for rooms without predictions
                if (!body) {
                    if (rt === 'R') {
                        body = '<div class="pred-info">Heal 30% HP or upgrade a card</div>';
                    } else if (rt === '$') {
                        body = '<div class="pred-info">Cards, relics, potions, card removal</div>';
                    } else if (rt === 'T') {
                        body = '<div class="pred-info">Contains a relic</div>';
                    } else if (rt === '?') {
                        body = '<div class="pred-info">Event outcome varies</div>';
                    } else if (rt === 'M' || rt === 'E') {
                        body = '<div class="pred-info">Combat encounter</div>';
                    } else {
                        body = '<div class="pred-info">No predictions</div>';
                    }
                }

                return `
                    <div class="pred-card ${rt}">
                        <div class="pred-header">
                            <div class="pred-icon ${rt}">${rt}</div>
                            <div class="pred-title">
                                <div class="pred-name">${name}${badges}</div>
                                ${sub ? `<div class="pred-sub">${sub}</div>` : ''}
                            </div>
                            <div class="pred-coords">(${n.x}, ${n.y})</div>
                        </div>
                        <div class="pred-body">${body}</div>
                    </div>
                `;
            }).join('');
        }

        function renderPathTree(state) {
            const container = document.getElementById('path-tree');
            if (!container) return;

            const pathTree = state.path_tree || {};
            const currentFloor = state.run?.floor || 0;

            // Check for error or empty tree
            if (pathTree.error) {
                container.innerHTML = `<div class="path-tree-empty">Error: ${pathTree.error}</div>`;
                return;
            }

            if (!pathTree.floor_1 || pathTree.floor_1.length === 0) {
                container.innerHTML = '<div class="path-tree-empty">No path data available</div>';
                return;
            }

            let html = '';

            // Render each floor level
            for (let floorNum = 1; floorNum <= 3; floorNum++) {
                const floorKey = `floor_${floorNum}`;
                const nodes = pathTree[floorKey] || [];

                if (nodes.length === 0) continue;

                // Calculate actual floor number
                const actualFloor = currentFloor + floorNum;

                // Add connector lines between floors (except before first)
                if (floorNum > 1) {
                    html += `<div class="path-tree-connectors">`;
                    for (let i = 0; i < Math.min(nodes.length, 6); i++) {
                        html += `<span class="path-tree-connector">|</span>`;
                    }
                    html += `</div>`;
                }

                html += `<div class="path-tree-floor">`;
                html += `<div class="path-tree-floor-label">Floor ${actualFloor}</div>`;
                html += `<div class="path-tree-nodes">`;

                for (const node of nodes) {
                    const rt = node.room_type || '?';
                    let name = getPathTreeNodeName(node, rt);
                    let details = getPathTreeNodeDetails(node, rt);
                    let tooltip = buildPathTreeTooltip(node, rt, actualFloor);

                    // Build card chips if available (floor 1 only has detailed predictions)
                    let cardsHtml = '';
                    if (node.cards && node.cards.length > 0) {
                        cardsHtml = `<div class="path-tree-node-cards">`;
                        for (const card of node.cards.slice(0, 3)) {
                            const isRare = isRareCard(card.replace('+', ''));
                            const isUpgraded = card.endsWith('+');
                            const cls = isRare ? 'rare' : (isUpgraded ? 'upgraded' : '');
                            cardsHtml += `<span class="path-tree-card-chip ${cls}">${formatShortCardName(card)}</span>`;
                        }
                        cardsHtml += `</div>`;
                    }

                    html += `
                        <div class="path-tree-node ${rt}" data-tooltip="${tooltip.replace(/"/g, '&quot;')}" data-x="${node.x}" data-y="${node.y}">
                            <div class="path-tree-node-header">
                                <div class="path-tree-node-icon ${rt}">${rt}</div>
                                <div class="path-tree-node-name" title="${name}">${name}</div>
                            </div>
                            <div class="path-tree-node-coords">(${node.x}, ${node.y})</div>
                            ${details ? `<div class="path-tree-node-details">${details}</div>` : ''}
                            ${cardsHtml}
                        </div>
                    `;
                }

                html += `</div></div>`;
            }

            container.innerHTML = html;

            // Add click handlers for path tree nodes to highlight on map
            container.querySelectorAll('.path-tree-node').forEach(el => {
                el.addEventListener('click', () => {
                    const x = parseInt(el.dataset.x);
                    const y = parseInt(el.dataset.y);

                    document.querySelectorAll('.map-node.path-highlight').forEach(n => n.classList.remove('path-highlight'));
                    const mapNode = document.querySelector(`.map-node[data-x="${x}"][data-y="${y}"]`);
                    if (mapNode) {
                        mapNode.classList.add('path-highlight');
                        mapNode.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                });

                el.addEventListener('mouseenter', () => {
                    const x = parseInt(el.dataset.x);
                    const y = parseInt(el.dataset.y);
                    const mapNode = document.querySelector(`.map-node[data-x="${x}"][data-y="${y}"]`);
                    if (mapNode) {
                        mapNode.classList.add('path-highlight');
                    }
                });

                el.addEventListener('mouseleave', () => {
                    document.querySelectorAll('.map-node.path-highlight').forEach(n => n.classList.remove('path-highlight'));
                });
            });
        }

        function getPathTreeNodeName(node, rt) {
            if (rt === 'M' && node.enemy) return node.enemy;
            if (rt === 'E' && node.enemy) return node.enemy;
            if (rt === '?' && node.event) return node.event;
            if (rt === 'B') return 'Boss';
            if (rt === 'R') return 'Rest';
            if (rt === '$') return 'Shop';
            if (rt === 'T') return node.relic || 'Treasure';
            return node.room_name || rt;
        }

        function getPathTreeNodeDetails(node, rt) {
            if (rt === 'T' && node.relic) return node.relic;
            if (rt === '$' && node.shop_relics && node.shop_relics.length > 0) {
                return node.shop_relics[0] + '...';
            }
            if (node.potion) return `Drop: ${node.potion}`;
            return '';
        }

        function buildPathTreeTooltip(node, rt, floor) {
            let lines = [`Floor ${floor}: ${getPathTreeNodeName(node, rt)}`];

            if (node.enemy) {
                const hp = MONSTER_HP[node.enemy];
                if (hp) lines.push(`HP: ${hp}`);
            }

            if (node.cards && node.cards.length > 0) {
                lines.push(`Cards: ${node.cards.join(', ')}`);
            }

            if (node.potion) {
                lines.push(`Potion: ${node.potion}`);
            }

            if (node.relic) {
                lines.push(`Relic: ${node.relic}`);
            }

            if (node.shop_cards && node.shop_cards.length > 0) {
                lines.push(`Shop Cards: ${node.shop_cards.slice(0, 3).join(', ')}...`);
            }

            if (node.shop_relics && node.shop_relics.length > 0) {
                lines.push(`Shop Relics: ${node.shop_relics.join(', ')}`);
            }

            if (node.boss_relics && node.boss_relics.length > 0) {
                lines.push(`Boss Relics: ${node.boss_relics.join(', ')}`);
            }

            if (node.parents && node.parents.length > 0) {
                const parentCoords = node.parents.map(p => `(${p.x},${p.y})`).join(', ');
                lines.push(`From: ${parentCoords}`);
            }

            return lines.join('\n');
        }

        function formatShortCardName(cardId) {
            if (!cardId) return '';
            const isUpgraded = cardId.endsWith('+');
            let name = cardId.replace(/\+$/, '');

            name = name
                .replace(/^(Strike_|Defend_)/, '')
                .replace(/_/g, ' ')
                .replace(/([a-z])([A-Z])/g, '$1 $2');

            if (name.length > 8) {
                name = name.substring(0, 7) + '..';
            }

            return name + (isUpgraded ? '+' : '');
        }

        // State for path view mode
        let pathViewMode = 'compact'; // 'compact' or 'list'
        let expandedFloor = null;
        let highlightedMapFloor = null;

        // Initialize path toggle button
        document.addEventListener('DOMContentLoaded', () => {
            const toggleBtn = document.getElementById('path-toggle-mode');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', () => {
                    pathViewMode = pathViewMode === 'compact' ? 'list' : 'compact';
                    toggleBtn.textContent = pathViewMode === 'compact' ? 'List' : 'Grid';
                    toggleBtn.classList.toggle('active', pathViewMode === 'list');
                    if (currentMapState) renderPath(currentMapState);
                });
            }
        });

        // Get act for a floor number
        function getActForFloor(floor) {
            if (floor <= 17) return 1;
            if (floor <= 34) return 2;
            if (floor <= 51) return 3;
            return 4;
        }

        // Get floor range for an act
        function getActFloorRange(act) {
            switch (act) {
                case 1: return [1, 17];
                case 2: return [18, 34];
                case 3: return [35, 51];
                case 4: return [52, 56];
                default: return [1, 17];
            }
        }

        // Highlight map node when hovering path entry
        function highlightMapNode(floor, state) {
            // Clear previous highlights
            document.querySelectorAll('.map-node.path-highlight').forEach(el => {
                el.classList.remove('path-highlight');
            });

            if (!floor || !state) return;

            // Find the node for this floor
            const history = state.floor_history || [];
            const floorData = history.find(f => f.floor === floor);
            if (!floorData) return;

            // If we have x,y coordinates, highlight that specific node
            if (floorData.x !== undefined && floorData.y !== undefined) {
                // Find the map node with matching x,y data attributes
                const mapNodes = document.querySelectorAll('.map-node');
                mapNodes.forEach(node => {
                    const nodeX = parseInt(node.dataset.x);
                    const nodeY = parseInt(node.dataset.y);
                    if (nodeX === floorData.x && nodeY === floorData.y) {
                        node.classList.add('path-highlight');
                    }
                });
            }
        }

        function renderNeowSection(state) {
            const neowSection = document.getElementById('neow-section');
            const neowOptions = document.getElementById('neow-options');
            const predictionsSection = document.getElementById('predictions-section');
            const floor = state.run?.floor || 0;

            // Only show Neow section at floor 0
            if (floor !== 0 || !state.neow_options || state.neow_options.length === 0) {
                if (neowSection) neowSection.style.display = 'none';
                if (predictionsSection) predictionsSection.style.display = 'block';
                return;
            }

            // Show Neow section, hide predictions section
            if (neowSection) neowSection.style.display = 'block';
            if (predictionsSection) predictionsSection.style.display = 'none';

            // Check for error
            if (state.neow_options[0]?.error) {
                neowOptions.innerHTML = `<div class="empty-state">Error: ${state.neow_options[0].error}</div>`;
                return;
            }

            // Render options
            const optionsHtml = state.neow_options.map(opt => {
                const categoryClass = opt.category || 'blessing';
                return `
                    <div class="neow-option ${categoryClass}">
                        <div class="neow-slot">Option ${opt.slot}</div>
                        <div class="neow-name">${opt.name}</div>
                        ${opt.drawback ? `<div class="neow-drawback">${opt.drawback}</div>` : ''}
                    </div>
                `;
            }).join('');

            neowOptions.innerHTML = optionsHtml;
        }

        function renderPath(state) {
            const history = state.floor_history || [];
            const pathTaken = state.path_taken || [];
            const currentFloor = state.run?.floor || 0;
            const container = document.getElementById('run-history');

            if (!pathTaken.length) {
                container.innerHTML = '<div class="empty-state">No path yet</div>';
                return;
            }

            // Group floors by act
            const actGroups = { 1: [], 2: [], 3: [], 4: [] };

            for (let i = 0; i < pathTaken.length; i++) {
                const floor = i + 1;
                const roomType = pathTaken[i];
                const floorData = history.find(f => f.floor === floor) || {};
                const act = getActForFloor(floor);

                actGroups[act].push({
                    floor,
                    roomType,
                    ...floorData,
                });
            }

            // Render based on view mode
            if (pathViewMode === 'compact') {
                container.innerHTML = renderCompactView(actGroups, currentFloor, state);
            } else {
                container.innerHTML = renderListView(actGroups, currentFloor, state);
            }

            // Add event listeners for floor interactions
            container.querySelectorAll('[data-floor]').forEach(el => {
                const floor = parseInt(el.dataset.floor);

                el.addEventListener('mouseenter', () => {
                    highlightMapNode(floor, state);
                });

                el.addEventListener('mouseleave', () => {
                    highlightMapNode(null, null);
                });

                el.addEventListener('click', () => {
                    if (expandedFloor === floor) {
                        expandedFloor = null;
                    } else {
                        expandedFloor = floor;
                    }
                    renderPath(state);
                });
            });
        }

        function renderCompactView(actGroups, currentFloor, state) {
            let html = '';

            for (const [act, floors] of Object.entries(actGroups)) {
                if (!floors.length) continue;

                // Calculate HP delta for this act
                const firstFloor = floors[0];
                const lastFloor = floors[floors.length - 1];
                let hpDelta = '';
                if (firstFloor.hp !== undefined && lastFloor.hp !== undefined) {
                    const delta = lastFloor.hp - (firstFloor.hp || 0);
                    if (delta !== 0) {
                        hpDelta = `<span class="act-hp">${delta > 0 ? '+' : ''}${delta}</span>`;
                    }
                }

                html += `
                    <div class="path-act">
                        <div class="path-act-header act-${act}">
                            <span>Act ${act}</span>
                            ${hpDelta}
                        </div>
                        <div class="path-grid">
                `;

                for (const f of floors) {
                    const isCurrent = f.floor === currentFloor;
                    const hasDamage = f.damage_taken > 0;
                    const hasCard = f.card_choice && f.card_choice.picked;
                    const classes = [
                        'path-node',
                        f.roomType,
                        isCurrent ? 'current' : '',
                        hasDamage ? 'took-damage' : '',
                        hasCard ? 'has-card' : '',
                    ].filter(Boolean).join(' ');

                    // Build enhanced tooltip with card choice info
                    let tooltip = `Floor ${f.floor}: ${getRoomTypeName(f.roomType)}`;
                    // Show encounter name (monster, elite, event, boss)
                    if (f.encounter) tooltip += `\n${formatEncounterName(f.encounter)}`;
                    else if (f.enemies?.length) tooltip += `\nEnemy: ${f.enemies.join(', ')}`;
                    if (f.damage_taken) tooltip += ` (-${f.damage_taken} HP)`;
                    if (f.card_choice) {
                        const picked = f.card_choice.picked;
                        const notPicked = f.card_choice.not_picked || [];
                        if (picked && picked !== 'SKIP') {
                            tooltip += `\nPicked: ${picked}`;
                        } else {
                            tooltip += `\nSkipped all cards`;
                        }
                        if (notPicked.length) {
                            tooltip += `\nSkipped: ${notPicked.join(', ')}`;
                        }
                    }
                    if (f.campfire) {
                        tooltip += `\n${f.campfire.key}`;
                        if (f.campfire.data) tooltip += `: ${f.campfire.data}`;
                    }

                    html += `
                        <div class="${classes}"
                             data-floor="${f.floor}"
                             title="${tooltip}">
                            ${f.roomType}
                        </div>
                    `;
                }

                html += `
                        </div>
                    </div>
                `;

                // Add boss divider after act boss floor
                const bossFloors = { 1: 17, 2: 34, 3: 51, 4: 56 };
                const bossFloor = floors.find(f => f.roomType === 'B');
                // JSON keys are strings, so use String(act) for lookup
                const actBosses = state.predicted_bosses?.[String(act)] || state.predicted_bosses?.[act];
                if (bossFloor && actBosses) {
                    const bossName = actBosses.join(' + ') || 'Boss';
                    html += `
                        <div class="path-boss-divider">
                            <span class="path-boss-name">${bossName}</span>
                        </div>
                    `;
                }
            }

            // Show expanded detail if a floor is selected
            if (expandedFloor) {
                html += renderFloorDetail(expandedFloor, actGroups, state);
            }

            return html;
        }

        function renderListView(actGroups, currentFloor, state) {
            let html = '';

            for (const [act, floors] of Object.entries(actGroups)) {
                if (!floors.length) continue;

                html += `
                    <div class="path-act">
                        <div class="path-act-header act-${act}">Act ${act}</div>
                        <div class="path-list">
                `;

                for (const f of floors) {
                    const isCurrent = f.floor === currentFloor;
                    const isExpanded = expandedFloor === f.floor;
                    const hasChoices = f.card_choice || f.campfire;
                    const classes = [
                        'path-item',
                        f.roomType,
                        isCurrent ? 'current' : '',
                        hasChoices ? 'has-choices' : '',
                    ].filter(Boolean).join(' ');

                    // Build stats display
                    let stats = '';
                    if (f.damage_taken > 0) {
                        stats += `<span class="hp-change">-${f.damage_taken}</span>`;
                    }
                    if (f.campfire?.key === 'REST') {
                        const healAmount = Math.floor((f.max_hp || 80) * 0.3);
                        stats += `<span class="hp-change heal">+${healAmount}</span>`;
                    }
                    if (f.gold !== undefined && floors.indexOf(f) > 0) {
                        const prevFloor = floors[floors.indexOf(f) - 1];
                        if (prevFloor.gold !== undefined) {
                            const goldDelta = f.gold - prevFloor.gold;
                            if (goldDelta !== 0) {
                                const goldClass = goldDelta < 0 ? 'negative' : '';
                                stats += `<span class="gold-change ${goldClass}">${goldDelta > 0 ? '+' : ''}${goldDelta}</span>`;
                            }
                        }
                    }

                    // Build card choice display
                    let cardChoicesHtml = '';
                    if (f.card_choice) {
                        cardChoicesHtml = renderCardChoices(f.card_choice, isExpanded);
                    }

                    // Build campfire choice display
                    let campfireHtml = '';
                    if (f.campfire) {
                        campfireHtml = renderCampfireChoice(f.campfire);
                    }

                    // Encounter name for all floor types
                    let encounterHtml = '';
                    const encounterName = f.encounter || (f.enemies?.length ? f.enemies[0] : null) ||
                                          (f.event?.name) || (f.campfire?.key);
                    if (encounterName) {
                        const encounterClass = f.roomType === 'E' ? 'elite' :
                                              f.roomType === '?' ? 'event' : '';
                        encounterHtml = `<span class="path-encounter ${encounterClass}" title="${encounterName}">${formatEncounterName(encounterName)}</span>`;
                    }

                    html += `
                        <div class="path-floor-wrapper" data-floor="${f.floor}">
                            <div class="${classes}">
                                <span class="path-floor">${f.floor}</span>
                                <div class="path-icon ${f.roomType}">${f.roomType}</div>
                                ${encounterHtml}
                                <div class="path-stats">${stats}</div>
                                ${hasChoices ? '<span class="expand-hint">...</span>' : ''}
                            </div>
                            ${cardChoicesHtml}
                            ${campfireHtml}
                    `;

                    // Show expanded detail inline in list view
                    if (isExpanded) {
                        html += renderFloorDetail(f.floor, actGroups, state);
                    }

                    html += '</div>';  // Close path-floor-wrapper
                }

                html += `
                        </div>
                    </div>
                `;

                // Boss divider
                const bossFloor = floors.find(f => f.roomType === 'B');
                // JSON keys are strings, so use String(act) for lookup
                const actBosses2 = state.predicted_bosses?.[String(act)] || state.predicted_bosses?.[act];
                if (bossFloor && actBosses2) {
                    const bossName = actBosses2.join(' + ') || 'Boss';
                    html += `
                        <div class="path-boss-divider">
                            <span class="path-boss-name">${bossName}</span>
                        </div>
                    `;
                }
            }

            return html;
        }

        // Render card choices as vertical list (picked first, then skipped)
        function renderCardChoices(choice, expanded) {
            const picked = choice.picked;
            const notPicked = choice.not_picked || [];

            if (!picked && !notPicked.length) return '';

            let html = '<div class="path-card-choices">';

            // Show picked card first (or skip indicator)
            if (picked && picked !== 'SKIP') {
                const isUpgraded = picked.endsWith('+');
                const displayName = formatCardNameFull(picked);
                html += `
                    <div class="card-choice-row">
                        <span class="card-choice-icon picked">+</span>
                        <span class="card-choice-name picked ${isUpgraded ? 'upgraded' : ''}">${displayName}</span>
                    </div>`;
            } else if (picked === 'SKIP' || !picked) {
                html += `
                    <div class="card-choice-row">
                        <span class="card-choice-icon skipped">-</span>
                        <span class="card-choice-name skip-all">Skip</span>
                    </div>`;
            }

            // Show skipped cards below
            for (const card of notPicked) {
                const displayName = formatCardNameFull(card);
                html += `
                    <div class="card-choice-row">
                        <span class="card-choice-icon skipped">-</span>
                        <span class="card-choice-name skipped">${displayName}</span>
                    </div>`;
            }

            html += '</div>';
            return html;
        }

        // Format card name for vertical display (no truncation)
        function formatCardNameFull(cardId) {
            if (!cardId) return '';
            return cardId
                .replace(/^(Strike_|Defend_)/, '')
                .replace(/_/g, ' ')
                .replace(/([a-z])([A-Z])/g, '$1 $2');
        }

        // Render campfire choice as vertical row
        function renderCampfireChoice(campfire) {
            const action = campfire.key;
            const data = campfire.data;

            let html = '<div class="path-card-choices">';

            // Show campfire action with optional card name
            let label = action;
            if (data && (action === 'SMITH' || action === 'TOKE')) {
                label += `: ${formatCardNameFull(data)}`;
            }

            const iconClass = action === 'REST' ? 'rest' : 'upgrade';
            const icon = action === 'REST' ? '+' : '*';
            html += `
                <div class="card-choice-row">
                    <span class="card-choice-icon campfire-${iconClass}">${icon}</span>
                    <span class="campfire-action ${action}">${label}</span>
                </div>`;

            html += '</div>';
            return html;
        }

        // Format card name for display (shorten if needed)
        function formatCardName(cardId) {
            if (!cardId) return '';
            // Remove common prefixes and format
            let name = cardId
                .replace(/^(Strike_|Defend_)/, '')  // Remove class prefixes
                .replace(/_/g, ' ')
                .replace(/([a-z])([A-Z])/g, '$1 $2');  // CamelCase to spaces

            // Truncate long names
            if (name.length > 12) {
                name = name.substring(0, 11) + '...';
            }
            return name;
        }

        function renderFloorDetail(floor, actGroups, state) {
            // Find the floor data
            let floorData = null;
            for (const floors of Object.values(actGroups)) {
                floorData = floors.find(f => f.floor === floor);
                if (floorData) break;
            }

            if (!floorData) return '';

            let detailHtml = '<div class="path-detail expanded">';

            // HP info
            if (floorData.hp !== undefined) {
                detailHtml += `
                    <div class="path-detail-row">
                        <span class="path-detail-label">HP</span>
                        <span class="path-detail-value">${floorData.hp}/${floorData.max_hp || '?'}</span>
                    </div>
                `;
            }

            // Damage taken
            if (floorData.damage_taken > 0) {
                detailHtml += `
                    <div class="path-detail-row">
                        <span class="path-detail-label">Damage</span>
                        <span class="path-detail-value" style="color: var(--crimson)">-${floorData.damage_taken} HP</span>
                    </div>
                `;
                if (floorData.enemies?.length) {
                    detailHtml += `
                        <div class="path-detail-row">
                            <span class="path-detail-label">Enemy</span>
                            <span class="path-detail-value">${floorData.enemies.join(', ')}</span>
                        </div>
                    `;
                }
                if (floorData.turns) {
                    detailHtml += `
                        <div class="path-detail-row">
                            <span class="path-detail-label">Turns</span>
                            <span class="path-detail-value">${floorData.turns}</span>
                        </div>
                    `;
                }
            }

            // Card choice
            if (floorData.card_choice) {
                detailHtml += `
                    <div class="path-detail-row">
                        <span class="path-detail-label">Cards</span>
                    </div>
                    <div class="path-cards">
                `;

                if (floorData.card_choice.picked) {
                    const isRare = RARE_CARDS.includes(floorData.card_choice.picked.replace(/\+$/, ''));
                    detailHtml += `<span class="path-card picked ${isRare ? 'rare' : ''}">${floorData.card_choice.picked}</span>`;
                }

                for (const card of (floorData.card_choice.not_picked || [])) {
                    const isRare = RARE_CARDS.includes(card.replace(/\+$/, ''));
                    detailHtml += `<span class="path-card ${isRare ? 'rare' : ''}">${card}</span>`;
                }

                detailHtml += '</div>';
            }

            // Event info
            if (floorData.event) {
                detailHtml += `
                    <div class="path-detail-row">
                        <span class="path-detail-label">Event</span>
                        <span class="path-detail-value">${floorData.event.name || 'Unknown'}</span>
                    </div>
                `;
                if (floorData.event.choice) {
                    detailHtml += `
                        <div class="path-detail-row">
                            <span class="path-detail-label">Choice</span>
                            <span class="path-detail-value">${floorData.event.choice}</span>
                        </div>
                    `;
                }
                if (floorData.event.damage > 0) {
                    detailHtml += `
                        <div class="path-detail-row">
                            <span class="path-detail-label">Damage</span>
                            <span class="path-detail-value" style="color: var(--crimson)">-${floorData.event.damage}</span>
                        </div>
                    `;
                }
                if (floorData.event.gold_change) {
                    const goldClass = floorData.event.gold_change < 0 ? 'color: var(--brass)' : 'color: var(--gold)';
                    detailHtml += `
                        <div class="path-detail-row">
                            <span class="path-detail-label">Gold</span>
                            <span class="path-detail-value" style="${goldClass}">${floorData.event.gold_change > 0 ? '+' : ''}${floorData.event.gold_change}</span>
                        </div>
                    `;
                }
            }

            // Campfire info
            if (floorData.campfire) {
                const action = floorData.campfire.key;
                let actionText = action;
                if (action === 'REST') actionText = 'Rest (heal 30%)';
                else if (action === 'SMITH') actionText = `Upgrade: ${floorData.campfire.data}`;
                else if (action === 'LIFT') actionText = 'Lift (+1 Str)';
                else if (action === 'DIG') actionText = 'Dig (relic)';
                else if (action === 'RECALL') actionText = 'Recall';
                else if (action === 'TOKE') actionText = `Toke: ${floorData.campfire.data}`;

                detailHtml += `
                    <div class="path-detail-row">
                        <span class="path-detail-label">Rest</span>
                        <span class="path-detail-value">${actionText}</span>
                    </div>
                `;
            }

            // Boss relic
            if (floorData.boss_relic) {
                detailHtml += `
                    <div class="path-detail-row">
                        <span class="path-detail-label">Relic</span>
                        <span class="path-detail-value" style="color: var(--violet)">${floorData.boss_relic.picked}</span>
                    </div>
                `;
                if (floorData.boss_relic.not_picked?.length) {
                    detailHtml += `
                        <div class="path-detail-row">
                            <span class="path-detail-label">Skipped</span>
                            <span class="path-detail-value" style="color: var(--text-muted)">${floorData.boss_relic.not_picked.join(', ')}</span>
                        </div>
                    `;
                }
            }

            // Gold at floor
            if (floorData.gold !== undefined) {
                detailHtml += `
                    <div class="path-detail-row">
                        <span class="path-detail-label">Gold</span>
                        <span class="path-detail-value" style="color: var(--gold)">${floorData.gold}</span>
                    </div>
                `;
            }

            detailHtml += '</div>';
            return detailHtml;
        }

        function getRoomTypeName(type) {
            const names = {
                'M': 'Monster',
                'E': 'Elite',
                'B': 'Boss',
                '$': 'Shop',
                'R': 'Rest',
                'T': 'Treasure',
                '?': 'Event',
            };
            return names[type] || type;
        }

        function formatEncounterName(name) {
            if (!name) return '';
            // Split camelCase/PascalCase into readable form
            return name
                .replace(/([A-Z])/g, ' $1')  // Add space before capitals
                .replace(/^./, s => s.toUpperCase())  // Capitalize first
                .replace(/\s+/g, ' ')  // Collapse multiple spaces
                .trim();
        }

        function setConnection(live, message) {
            const el = document.getElementById('conn');
            const txt = document.getElementById('conn-text');
            el.classList.toggle('live', live);
            txt.textContent = message || (live ? 'Live' : 'Offline');
        }

        // Track if we've received initial state
        let hasInitialState = false;

        // Manual refresh function
        function refreshState() {
            setConnection(false, 'Refreshing...');
            fetch('/api/state')
                .then(r => {
                    if (!r.ok) throw new Error(`HTTP ${r.status}`);
                    return r.json();
                })
                .then(data => {
                    console.log('[STS] State refreshed:', data);
                    hasInitialState = true;
                    update(data);
                    setConnection(true, 'Live');
                })
                .catch(err => {
                    console.error('[STS] Refresh failed:', err);
                    setConnection(false, 'Error: ' + err.message);
                });
        }

        let eventSource;
        function connect() {
            if (eventSource) eventSource.close();
            setConnection(false, 'Connecting...');
            eventSource = new EventSource('/api/stream');
            eventSource.onopen = () => {
                console.log('[STS] SSE connected');
                setConnection(true, 'Live');
            };
            eventSource.onmessage = (e) => {
                try {
                    const data = JSON.parse(e.data);
                    if (data.error) {
                        console.warn('[STS] Server error:', data.error);
                        setConnection(false, data.error);
                        return;
                    }
                    hasInitialState = true;
                    update(data);
                    setConnection(true, 'Live');
                } catch (err) {
                    console.error('[STS] Parse error:', err, e.data);
                }
            };
            eventSource.onerror = (err) => {
                console.error('[STS] SSE error:', err);
                setConnection(false, 'Offline');
                setTimeout(connect, 3000);
            };
        }

        // ==========================================
        // PATH PLANNING SYSTEM
        // ==========================================

        // State for path planning
        let plannedPath = [];
        let savedPaths = [];
        let comparingPath = null;
        let planningMode = true;

        // Expected values per room type
        const ROOM_ESTIMATES = {
            'M': { hp: -8, gold: 20, cards: 1, potionChance: 0.4, relicChance: 0 },
            'E': { hp: -18, gold: 35, cards: 1, potionChance: 0.4, relicChance: 0.25 },
            'B': { hp: -25, gold: 100, cards: 1, potionChance: 0.4, relicChance: 1.0 },
            '?': { hp: -5, gold: 15, cards: 0.3, potionChance: 0.1, relicChance: 0.1 },
            '$': { hp: 0, gold: -100, cards: 0, potionChance: 0, relicChance: 0.5 },
            'R': { hp: 24, gold: 0, cards: 0, potionChance: 0, relicChance: 0 },
            'T': { hp: 0, gold: 50, cards: 0, potionChance: 0, relicChance: 1.0 },
        };

        // Check if a node is accessible from the planned path or current position
        function canAddToPlan(node, state) {
            const map = state.map || [];
            const curX = state.current_position?.x ?? -1;
            const curY = state.current_position?.y ?? -1;

            // If no planned path yet, check if node is accessible from current position
            if (plannedPath.length === 0) {
                // At floor 0 (before first move), can access all row 0 nodes
                if (curY < 0 || curX < 0) {
                    return node.y === 0 && node.has_edges;
                }
                // Otherwise, node must be reachable from current position
                const currentNode = map[curY]?.find(n => n.x === curX);
                if (currentNode && currentNode.edges) {
                    return currentNode.edges.some(e => e.dst_x === node.x && e.dst_y === node.y);
                }
                return false;
            }

            // Check if node is accessible from last planned node
            const lastPlanned = plannedPath[plannedPath.length - 1];
            const lastNode = map[lastPlanned.y]?.find(n => n.x === lastPlanned.x);
            if (lastNode && lastNode.edges) {
                return lastNode.edges.some(e => e.dst_x === node.x && e.dst_y === node.y);
            }
            return false;
        }

        // Add node to planned path
        function addToPlannedPath(node) {
            // Don't add if already in path
            if (plannedPath.some(n => n.x === node.x && n.y === node.y)) {
                // If clicking the last node, remove it
                if (plannedPath.length > 0) {
                    const last = plannedPath[plannedPath.length - 1];
                    if (last.x === node.x && last.y === node.y) {
                        plannedPath.pop();
                        updatePlannedPathUI();
                        updatePreviewPanel();
                        return;
                    }
                }
                return;
            }

            plannedPath.push({
                x: node.x,
                y: node.y,
                room_type: node.room_type,
                room_name: node.room_name,
            });

            updatePlannedPathUI();
            updatePreviewPanel();
        }

        // Clear planned path
        function clearPlannedPath() {
            plannedPath = [];
            comparingPath = null;
            updatePlannedPathUI();
            updatePreviewPanel();
            document.getElementById('comparison-panel').classList.remove('visible');
        }

        // Save current planned path
        function savePlannedPath() {
            if (plannedPath.length === 0) return;

            const pathName = `Path ${savedPaths.length + 1}`;
            const summary = calculatePathSummary(plannedPath);

            savedPaths.push({
                name: pathName,
                nodes: [...plannedPath],
                summary: summary,
            });

            updateSavedPathsUI();
        }

        // Calculate path summary statistics
        function calculatePathSummary(path) {
            let hp = 0;
            let gold = 0;
            let cards = 0;
            let potions = 0;
            let relics = 0;
            let fights = 0;
            let elites = 0;

            path.forEach(node => {
                const rt = node.room_type;
                const estimates = ROOM_ESTIMATES[rt] || {};

                hp += estimates.hp || 0;
                gold += estimates.gold || 0;
                cards += estimates.cards || 0;
                potions += estimates.potionChance || 0;
                relics += estimates.relicChance || 0;

                if (rt === 'M') fights++;
                if (rt === 'E') { fights++; elites++; }
            });

            return { hp, gold, cards, potions, relics, fights, elites };
        }

        // Update planned path visual on map
        function updatePlannedPathUI() {
            // Remove existing planned markers
            document.querySelectorAll('.map-node.planned, .map-node.planned-start, .map-node.planned-next')
                .forEach(el => {
                    el.classList.remove('planned', 'planned-start', 'planned-next');
                });

            // Show/hide planned path section
            const section = document.getElementById('planned-path-section');
            if (plannedPath.length > 0) {
                section.style.display = 'block';
                document.getElementById('main-content')?.classList.add('with-preview');
                document.getElementById('preview-column').classList.add('visible');
            } else {
                section.style.display = 'none';
                document.getElementById('preview-column').classList.remove('visible');
            }

            // Mark planned nodes on map
            plannedPath.forEach((node, idx) => {
                const nodeEl = document.querySelector(`.map-node[data-x="${node.x}"][data-y="${node.y}"]`);
                if (nodeEl) {
                    nodeEl.classList.add('planned');
                    if (idx === 0) nodeEl.classList.add('planned-start');
                }
            });

            // Mark next accessible nodes
            if (plannedPath.length > 0 && currentMapState) {
                const lastPlanned = plannedPath[plannedPath.length - 1];
                const map = currentMapState.map;
                const lastNode = map[lastPlanned.y]?.find(n => n.x === lastPlanned.x);

                if (lastNode && lastNode.edges) {
                    lastNode.edges.forEach(edge => {
                        if (!edge.is_boss) {
                            const nodeEl = document.querySelector(`.map-node[data-x="${edge.dst_x}"][data-y="${edge.dst_y}"]`);
                            if (nodeEl && !nodeEl.classList.contains('planned')) {
                                nodeEl.classList.add('planned-next');
                            }
                        }
                    });
                }
            }

            // Render planned path timeline
            const timelineEl = document.getElementById('planned-path');
            if (plannedPath.length === 0) {
                timelineEl.innerHTML = '<div class="empty-state">Click nodes to plan</div>';
            } else {
                timelineEl.innerHTML = plannedPath.map((node, i) => `
                    <div class="planned-path-item" data-idx="${i}">
                        <span class="path-floor">${i + 1}</span>
                        <div class="planned-path-icon ${node.room_type}">${node.room_type}</div>
                    </div>
                `).join('');

                // Add click handlers to remove nodes
                document.querySelectorAll('.planned-path-item').forEach(el => {
                    el.addEventListener('click', () => {
                        const idx = parseInt(el.dataset.idx);
                        plannedPath = plannedPath.slice(0, idx);
                        updatePlannedPathUI();
                        updatePreviewPanel();
                    });
                });
            }
        }

        // Update preview panel with cumulative stats
        function updatePreviewPanel() {
            if (plannedPath.length === 0) {
                document.getElementById('preview-column').classList.remove('visible');
                return;
            }

            document.getElementById('preview-column').classList.add('visible');

            // Render path nodes
            const nodesHtml = plannedPath.map(node =>
                `<div class="preview-path-node ${node.room_type}">${node.room_type}</div>`
            ).join('');
            document.getElementById('preview-path-nodes').innerHTML = nodesHtml;

            // Calculate summary
            const summary = calculatePathSummary(plannedPath);

            // Update stats
            const hpEl = document.getElementById('preview-hp');
            hpEl.textContent = (summary.hp >= 0 ? '+' : '') + summary.hp;
            hpEl.className = 'preview-stat-value ' + (summary.hp > 0 ? 'positive' : summary.hp < 0 ? 'negative' : 'neutral');

            const goldEl = document.getElementById('preview-gold');
            goldEl.textContent = (summary.gold >= 0 ? '+' : '') + summary.gold;
            goldEl.className = 'preview-stat-value ' + (summary.gold > 0 ? 'positive' : summary.gold < 0 ? 'negative' : 'neutral');

            document.getElementById('preview-fights').textContent = summary.fights;
            document.getElementById('preview-elites').textContent = summary.elites;

            // Get card predictions for planned path
            updateCardPredictions();

            // Update comparison if active
            if (comparingPath) {
                updateComparisonPanel(summary);
            }
        }

        // Update card predictions for planned path
        async function updateCardPredictions() {
            const cardsEl = document.getElementById('preview-cards');
            const relicsEl = document.getElementById('preview-relics');
            const potionsEl = document.getElementById('preview-potions');

            if (plannedPath.length === 0) {
                cardsEl.innerHTML = '<span class="empty-state">No cards predicted</span>';
                relicsEl.innerHTML = '<span class="empty-state">None expected</span>';
                potionsEl.innerHTML = '<span class="empty-state">Varies by fight</span>';
                return;
            }

            // Try to fetch predictions from server
            try {
                const response = await fetch('/api/predict/path', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        path: plannedPath.map(n => ({ x: n.x, y: n.y })),
                    }),
                });

                if (response.ok) {
                    const data = await response.json();

                    // Cards
                    if (data.cards && data.cards.length > 0) {
                        cardsEl.innerHTML = data.cards.map(c => {
                            const up = c.endsWith('+');
                            const rare = isRareCard(c.replace('+', ''));
                            return `<span class="preview-card-chip ${up ? 'upgraded' : ''} ${rare ? 'rare' : ''}">${c}</span>`;
                        }).join('');
                    }

                    // Relics
                    if (data.relics && data.relics.length > 0) {
                        relicsEl.innerHTML = data.relics.map(r =>
                            `<span class="preview-relic-chip">${r}</span>`
                        ).join('');
                    }

                    // Potions
                    if (data.potions && data.potions.length > 0) {
                        potionsEl.innerHTML = data.potions.map(p =>
                            `<span class="preview-potion-chip">${p}</span>`
                        ).join('');
                    }

                    return;
                }
            } catch (e) {
                // API not available, use estimates
            }

            // Fallback: show estimated info based on room types
            const combatNodes = plannedPath.filter(n => n.room_type === 'M' || n.room_type === 'E');
            if (combatNodes.length > 0) {
                cardsEl.innerHTML = `<span class="empty-state">${combatNodes.length} card reward(s) expected</span>`;
            }

            const relicNodes = plannedPath.filter(n => n.room_type === 'E' || n.room_type === 'T');
            if (relicNodes.length > 0) {
                relicsEl.innerHTML = `<span class="empty-state">~${relicNodes.length} relic(s) possible</span>`;
            }

            potionsEl.innerHTML = `<span class="empty-state">~40% per fight</span>`;
        }

        // Update saved paths UI
        function updateSavedPathsUI() {
            const listEl = document.getElementById('saved-paths-list');

            if (savedPaths.length === 0) {
                listEl.innerHTML = '<div class="empty-state">No saved paths</div>';
                return;
            }

            listEl.innerHTML = savedPaths.map((path, idx) => `
                <div class="saved-path-item ${comparingPath === idx ? 'comparing' : ''}" data-idx="${idx}">
                    <div class="saved-path-info">
                        <div class="saved-path-name">${path.name}</div>
                        <div class="saved-path-summary">
                            ${path.nodes.length} nodes | HP: ${path.summary.hp >= 0 ? '+' : ''}${path.summary.hp} | Gold: ${path.summary.gold >= 0 ? '+' : ''}${path.summary.gold}
                        </div>
                    </div>
                    <div class="saved-path-actions">
                        <span class="saved-path-btn load" data-action="compare" title="Compare">vs</span>
                        <span class="saved-path-btn load" data-action="load" title="Load">L</span>
                        <span class="saved-path-btn delete" data-action="delete" title="Delete">X</span>
                    </div>
                </div>
            `).join('');

            // Add click handlers
            document.querySelectorAll('.saved-path-item').forEach(el => {
                el.querySelectorAll('.saved-path-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const idx = parseInt(el.dataset.idx);
                        const action = btn.dataset.action;

                        if (action === 'delete') {
                            savedPaths.splice(idx, 1);
                            if (comparingPath === idx) comparingPath = null;
                            updateSavedPathsUI();
                        } else if (action === 'load') {
                            plannedPath = [...savedPaths[idx].nodes];
                            updatePlannedPathUI();
                            updatePreviewPanel();
                        } else if (action === 'compare') {
                            comparingPath = comparingPath === idx ? null : idx;
                            updateSavedPathsUI();
                            updatePreviewPanel();
                            document.getElementById('comparison-panel').classList.toggle('visible', comparingPath !== null);
                        }
                    });
                });
            });
        }

        // Update comparison panel
        function updateComparisonPanel(currentSummary) {
            if (comparingPath === null || !savedPaths[comparingPath]) return;

            const savedSummary = savedPaths[comparingPath].summary;

            // HP
            document.getElementById('cmp-hp-current').textContent = (currentSummary.hp >= 0 ? '+' : '') + currentSummary.hp;
            document.getElementById('cmp-hp-saved').textContent = (savedSummary.hp >= 0 ? '+' : '') + savedSummary.hp;
            const hpDiff = currentSummary.hp - savedSummary.hp;
            const hpDiffEl = document.getElementById('cmp-hp-diff');
            hpDiffEl.textContent = (hpDiff >= 0 ? '+' : '') + hpDiff;
            hpDiffEl.className = 'comparison-diff ' + (hpDiff > 0 ? 'better' : hpDiff < 0 ? 'worse' : '');

            // Gold
            document.getElementById('cmp-gold-current').textContent = (currentSummary.gold >= 0 ? '+' : '') + currentSummary.gold;
            document.getElementById('cmp-gold-saved').textContent = (savedSummary.gold >= 0 ? '+' : '') + savedSummary.gold;
            const goldDiff = currentSummary.gold - savedSummary.gold;
            const goldDiffEl = document.getElementById('cmp-gold-diff');
            goldDiffEl.textContent = (goldDiff >= 0 ? '+' : '') + goldDiff;
            goldDiffEl.className = 'comparison-diff ' + (goldDiff > 0 ? 'better' : goldDiff < 0 ? 'worse' : '');

            // Cards
            document.getElementById('cmp-cards-current').textContent = currentSummary.cards.toFixed(1);
            document.getElementById('cmp-cards-saved').textContent = savedSummary.cards.toFixed(1);
            const cardsDiff = currentSummary.cards - savedSummary.cards;
            const cardsDiffEl = document.getElementById('cmp-cards-diff');
            cardsDiffEl.textContent = (cardsDiff >= 0 ? '+' : '') + cardsDiff.toFixed(1);
            cardsDiffEl.className = 'comparison-diff ' + (cardsDiff > 0 ? 'better' : cardsDiff < 0 ? 'worse' : '');
        }

        // Override handleNodeClick to support path planning
        const originalHandleNodeClick = handleNodeClick;
        handleNodeClick = function(e) {
            const el = e.currentTarget;
            const nodeData = JSON.parse(el.dataset.node);

            // Check if in planning mode and node can be added
            if (planningMode && currentMapState) {
                if (canAddToPlan(nodeData, currentMapState)) {
                    addToPlannedPath(nodeData);
                    return;
                }
                // If node is already in path and is the last one, remove it
                if (plannedPath.length > 0) {
                    const last = plannedPath[plannedPath.length - 1];
                    if (last.x === nodeData.x && last.y === nodeData.y) {
                        plannedPath.pop();
                        updatePlannedPathUI();
                        updatePreviewPanel();
                        return;
                    }
                }
            }

            // Fall back to original behavior (node detail panel)
            originalHandleNodeClick.call(this, e);
        };

        // Initialize path planning controls
        document.addEventListener('DOMContentLoaded', () => {
            // Plan mode button
            const planBtn = document.getElementById('btn-plan-mode');
            if (planBtn) {
                planBtn.addEventListener('click', () => {
                    planningMode = !planningMode;
                    planBtn.classList.toggle('active', planningMode);
                });
            }

            // Save button
            const saveBtn = document.getElementById('btn-save-path');
            if (saveBtn) {
                saveBtn.addEventListener('click', savePlannedPath);
            }

            // Clear button
            const clearBtn = document.getElementById('btn-clear-path');
            if (clearBtn) {
                clearBtn.addEventListener('click', clearPlannedPath);
            }

            // Preview close button
            const previewCloseBtn = document.getElementById('preview-close');
            if (previewCloseBtn) {
                previewCloseBtn.addEventListener('click', () => {
                    document.getElementById('preview-column').classList.remove('visible');
                });
            }
        });

        // ==========================================
        // END PATH PLANNING SYSTEM
        // ==========================================

        // Initialize: fetch initial state, then connect to SSE
        console.log('[STS] Dashboard initializing...');
        setConnection(false, 'Loading...');

        fetch('/api/state')
            .then(r => {
                if (!r.ok) throw new Error(`HTTP ${r.status}`);
                return r.json();
            })
            .then(data => {
                console.log('[STS] Initial state loaded:', data);
                if (data.error) {
                    console.warn('[STS] Server returned error:', data.error);
                    setConnection(false, data.error);
                } else {
                    hasInitialState = true;
                    update(data);
                    setConnection(true, 'Live');
                }
            })
            .catch(err => {
                console.error('[STS] Initial fetch failed:', err);
                setConnection(false, 'Failed to load');
            })
            .finally(() => {
                // Always connect SSE for live updates
                connect();
            });
    </script>
</body>
</html>
