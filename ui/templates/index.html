<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seed Oracle - Slay the Spire Prediction</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=IM+Fell+English:ital@0;1&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0a0a0f;
            --bg-card: #12121a;
            --bg-node: #1a1a25;
            --border-glow: #3d5a80;
            --accent-gold: #d4a857;
            --accent-red: #8b2635;
            --accent-green: #2d5a3d;
            --accent-blue: #3d5a80;
            --accent-purple: #5a3d6e;
            --text-primary: #e8e4d9;
            --text-secondary: #9a9486;
            --text-muted: #5a5650;
            --monster: #8b2635;
            --elite: #d4a857;
            --rest: #2d5a3d;
            --shop: #d4a857;
            --event: #3d5a80;
            --treasure: #d4a857;
            --boss: #5a3d6e;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Text', Georgia, serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Noise texture overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            opacity: 0.03;
            pointer-events: none;
            z-index: 1000;
        }

        /* Header */
        .header {
            background: linear-gradient(180deg, rgba(20, 20, 30, 0.95) 0%, rgba(10, 10, 15, 0.8) 100%);
            border-bottom: 1px solid rgba(212, 168, 87, 0.2);
            padding: 1.5rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .logo {
            font-family: 'Cinzel', serif;
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent-gold);
            text-shadow: 0 0 20px rgba(212, 168, 87, 0.3);
            letter-spacing: 0.1em;
        }

        .logo span {
            color: var(--text-secondary);
            font-weight: 400;
        }

        /* Seed Input */
        .seed-input-container {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .seed-input {
            font-family: 'IM Fell English', serif;
            font-size: 1.2rem;
            padding: 0.75rem 1.5rem;
            background: rgba(26, 26, 37, 0.8);
            border: 1px solid rgba(212, 168, 87, 0.3);
            border-radius: 4px;
            color: var(--text-primary);
            width: 200px;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            transition: all 0.3s ease;
        }

        .seed-input:focus {
            outline: none;
            border-color: var(--accent-gold);
            box-shadow: 0 0 20px rgba(212, 168, 87, 0.2);
        }

        .seed-input::placeholder {
            color: var(--text-muted);
            text-transform: none;
            letter-spacing: normal;
        }

        .ascension-select {
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
            padding: 0.75rem 1rem;
            background: rgba(26, 26, 37, 0.8);
            border: 1px solid rgba(212, 168, 87, 0.3);
            border-radius: 4px;
            color: var(--accent-gold);
            cursor: pointer;
            transition: all 0.3s ease;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23d4a857' d='M6 8L2 4h8z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            padding-right: 2rem;
        }

        .ascension-select:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 0 10px rgba(212, 168, 87, 0.2);
        }

        .ascension-select:focus {
            outline: none;
            border-color: var(--accent-gold);
            box-shadow: 0 0 15px rgba(212, 168, 87, 0.3);
        }

        .ascension-select option {
            background: var(--bg-card);
            color: var(--text-primary);
        }

        .btn {
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(180deg, rgba(212, 168, 87, 0.2) 0%, rgba(212, 168, 87, 0.1) 100%);
            border: 1px solid rgba(212, 168, 87, 0.4);
            border-radius: 4px;
            color: var(--accent-gold);
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .btn:hover {
            background: linear-gradient(180deg, rgba(212, 168, 87, 0.3) 0%, rgba(212, 168, 87, 0.15) 100%);
            box-shadow: 0 0 20px rgba(212, 168, 87, 0.3);
            transform: translateY(-1px);
        }

        /* Main Layout */
        .main-container {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 0;
            min-height: calc(100vh - 80px);
        }

        /* Map Section */
        .map-section {
            padding: 2rem;
            background: radial-gradient(ellipse at center, rgba(26, 26, 37, 0.5) 0%, transparent 70%);
            position: relative;
            overflow: hidden;
        }

        .map-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                radial-gradient(circle at 20% 30%, rgba(61, 90, 128, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(90, 61, 110, 0.05) 0%, transparent 50%);
            pointer-events: none;
        }

        /* Act Tabs */
        .act-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            justify-content: center;
        }

        .act-tab {
            font-family: 'Cinzel', serif;
            font-size: 0.85rem;
            padding: 0.6rem 1.2rem;
            background: rgba(26, 26, 37, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .act-tab:hover {
            background: rgba(26, 26, 37, 0.9);
            color: var(--text-primary);
        }

        .act-tab.active {
            background: linear-gradient(180deg, rgba(212, 168, 87, 0.15) 0%, rgba(212, 168, 87, 0.05) 100%);
            border-color: rgba(212, 168, 87, 0.4);
            color: var(--accent-gold);
        }

        /* Map Canvas Container */
        .map-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
            aspect-ratio: 7/16;
        }

        #map-canvas {
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        /* Neow Section */
        .neow-section {
            background: linear-gradient(180deg, rgba(26, 26, 37, 0.9) 0%, rgba(18, 18, 26, 0.95) 100%);
            border: 1px solid rgba(212, 168, 87, 0.15);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .neow-title {
            font-family: 'Cinzel', serif;
            font-size: 1.1rem;
            color: var(--accent-gold);
            text-align: center;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
        }

        .neow-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
        }

        .neow-option {
            background: rgba(26, 26, 37, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 6px;
            padding: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .neow-option:hover {
            background: rgba(26, 26, 37, 0.9);
            border-color: rgba(212, 168, 87, 0.3);
            transform: translateY(-2px);
        }

        /* Boss swap option - same styling as others in 2x2 grid */

        .neow-slot {
            font-family: 'Cinzel', serif;
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.25rem;
        }

        .neow-name {
            font-size: 0.9rem;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
        }

        .neow-drawback {
            font-size: 0.8rem;
            color: var(--accent-red);
            font-style: italic;
        }

        /* Details Panel */
        .details-panel {
            background: linear-gradient(180deg, #14141e 0%, #0f0f17 100%);
            border-left: 1px solid rgba(212, 168, 87, 0.15);
            padding: 1.5rem;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
        }

        .panel-title {
            font-family: 'Cinzel', serif;
            font-size: 0.85rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .seed-display {
            font-family: 'IM Fell English', serif;
            font-size: 1.6rem;
            color: var(--accent-gold);
            text-align: center;
            margin-bottom: 0.25rem;
            letter-spacing: 0.1em;
        }

        .seed-value {
            font-family: 'Crimson Text', serif;
            font-size: 0.85rem;
            color: var(--text-muted);
            text-align: center;
            margin-bottom: 1.5rem;
        }

        /* Floor Details */
        .floor-details {
            background: rgba(26, 26, 37, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 1.25rem;
            margin-bottom: 1rem;
        }

        .floor-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .floor-number {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-gold);
            min-width: 2.5rem;
        }

        .room-type {
            font-family: 'Cinzel', serif;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 0.3rem 0.75rem;
            border-radius: 4px;
            background: rgba(139, 38, 53, 0.3);
            color: var(--monster);
        }

        .room-type.elite { background: rgba(212, 168, 87, 0.2); color: var(--elite); }
        .room-type.rest { background: rgba(45, 90, 61, 0.3); color: var(--rest); }
        .room-type.shop { background: rgba(212, 168, 87, 0.2); color: var(--shop); }
        .room-type.event { background: rgba(61, 90, 128, 0.3); color: var(--event); }
        .room-type.treasure { background: rgba(212, 168, 87, 0.2); color: var(--treasure); }
        .room-type.boss { background: rgba(90, 61, 110, 0.3); color: var(--boss); }

        .enemy-info {
            margin-bottom: 1rem;
        }

        .enemy-name {
            font-family: 'Cinzel', serif;
            font-size: 1.1rem;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .enemy-hp {
            font-size: 0.9rem;
            color: var(--accent-red);
            margin-bottom: 0.25rem;
        }

        .enemy-move {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .rewards-section {
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            padding-top: 1rem;
        }

        .reward-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .reward-label {
            color: var(--text-muted);
            min-width: 60px;
        }

        .reward-value {
            color: var(--text-primary);
        }

        .card-reward {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            background: rgba(26, 26, 37, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-right: 0.25rem;
            font-size: 0.8rem;
        }

        .card-reward.common { border-color: rgba(150, 150, 150, 0.3); }
        .card-reward.uncommon { border-color: rgba(61, 90, 128, 0.5); color: #6b9ac4; }
        .card-reward.rare { border-color: rgba(212, 168, 87, 0.5); color: var(--accent-gold); }

        /* Encounter List */
        .encounter-list {
            margin-top: 1.5rem;
        }

        .encounter-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 0.85rem;
        }

        .encounter-idx {
            font-family: 'Cinzel', serif;
            font-size: 0.75rem;
            color: var(--text-muted);
            min-width: 1.5rem;
        }

        .encounter-name {
            color: var(--text-primary);
        }

        .encounter-type {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-left: auto;
        }

        /* Boss Section */
        .boss-section {
            margin-top: 1.5rem;
            background: linear-gradient(180deg, rgba(90, 61, 110, 0.15) 0%, rgba(90, 61, 110, 0.05) 100%);
            border: 1px solid rgba(90, 61, 110, 0.3);
            border-radius: 8px;
            padding: 1.25rem;
        }

        .boss-name {
            font-family: 'Cinzel', serif;
            font-size: 1.2rem;
            color: var(--accent-purple);
            margin-bottom: 0.5rem;
        }

        .boss-hp {
            font-size: 0.9rem;
            color: var(--accent-red);
        }

        /* Loading State */
        .loading {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted);
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--text-muted);
            border-top-color: var(--accent-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 0.5rem;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 3rem 1.5rem;
            color: var(--text-muted);
        }

        .empty-state h3 {
            font-family: 'Cinzel', serif;
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(212, 168, 87, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(212, 168, 87, 0.5);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 1fr;
            }

            .details-panel {
                border-left: none;
                border-top: 1px solid rgba(212, 168, 87, 0.15);
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">SEED <span>ORACLE</span></div>
        <div class="seed-input-container">
            <input type="text" id="seed-input" class="seed-input" placeholder="Enter seed..." value="A20WIN">
            <select id="ascension-select" class="ascension-select" onchange="loadSeed()">
                <option value="0">A0</option>
                <option value="1">A1</option>
                <option value="5">A5</option>
                <option value="10">A10</option>
                <option value="15">A15</option>
                <option value="17">A17</option>
                <option value="20" selected>A20</option>
            </select>
            <button class="btn" onclick="loadSeed()">Divine</button>
        </div>
    </header>

    <main class="main-container">
        <section class="map-section">
            <!-- Neow Options -->
            <div class="neow-section" id="neow-section">
                <div class="neow-title">Neow's Blessing</div>
                <div class="neow-options" id="neow-options">
                    <div class="empty-state">Enter a seed to reveal Neow's offerings</div>
                </div>
            </div>

            <!-- Act Tabs -->
            <div class="act-tabs">
                <button class="act-tab active" data-act="1" onclick="switchAct(1)">Act I</button>
                <button class="act-tab" data-act="2" onclick="switchAct(2)">Act II</button>
                <button class="act-tab" data-act="3" onclick="switchAct(3)">Act III</button>
                <button class="act-tab" data-act="4" onclick="switchAct(4)">Act IV</button>
            </div>

            <!-- Map -->
            <div class="map-container">
                <canvas id="map-canvas"></canvas>
            </div>
        </section>

        <aside class="details-panel">
            <div class="panel-title">Seed Details</div>

            <div id="seed-info">
                <div class="empty-state">
                    <h3>No Seed Selected</h3>
                    <p>Enter a seed to view predictions</p>
                </div>
            </div>

            <div id="floor-details" style="display: none;">
                <!-- Populated dynamically -->
            </div>

            <div class="encounter-list" id="encounter-list">
                <!-- Populated dynamically -->
            </div>

            <div class="boss-section" id="boss-section" style="display: none;">
                <!-- Populated dynamically -->
            </div>
        </aside>
    </main>

    <script>
        // State
        let currentSeed = null;
        let currentAct = 1;
        let currentAscension = 20;
        let seedData = null;
        let selectedNode = null;
        let selectedPath = [];  // Array of {x, y, type} for path tracking
        let pathEncounters = { normal: 0, elite: 0 };  // Track encounter indices along path
        let eventPredictions = {};  // Map of "x,y" to prediction

        // Canvas setup
        const canvas = document.getElementById('map-canvas');
        const ctx = canvas.getContext('2d');

        // Room type colors
        const ROOM_COLORS = {
            'MONSTER': '#8b2635',
            'ELITE': '#d4a857',
            'REST': '#2d5a3d',
            'SHOP': '#d4a857',
            'EVENT': '#3d5a80',
            'TREASURE': '#d4a857',
            'BOSS': '#5a3d6e',
        };

        const ROOM_SYMBOLS = {
            'MONSTER': 'M',
            'ELITE': 'E',
            'REST': 'R',
            'SHOP': '$',
            'EVENT': '?',
            'TREASURE': 'T',
            'BOSS': 'B',
        };

        // Resize canvas
        function resizeCanvas() {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            if (seedData) drawMap();
        }

        window.addEventListener('resize', resizeCanvas);

        // Load seed data
        async function loadSeed() {
            const input = document.getElementById('seed-input');
            const ascSelect = document.getElementById('ascension-select');
            const seed = input.value.trim().toUpperCase();
            if (!seed) return;

            currentSeed = seed;
            currentAscension = parseInt(ascSelect.value);

            // Clear path when loading new seed
            selectedPath = [];
            pathEncounters = { normal: 0, elite: 0 };

            try {
                const response = await fetch(`/api/seed/${seed}?act=${currentAct}&ascension=${currentAscension}`);
                seedData = await response.json();
                updateUI();
                updatePathDisplay();
            } catch (error) {
                console.error('Error loading seed:', error);
            }
        }

        // Switch act
        async function switchAct(act) {
            currentAct = act;
            document.querySelectorAll('.act-tab').forEach(tab => {
                tab.classList.toggle('active', parseInt(tab.dataset.act) === act);
            });

            // Clear path when switching acts
            selectedPath = [];
            pathEncounters = { normal: 0, elite: 0 };

            if (currentSeed) {
                try {
                    const response = await fetch(`/api/seed/${currentSeed}?act=${act}&ascension=${currentAscension}`);
                    seedData = await response.json();
                    updateUI();
                    updatePathDisplay();
                } catch (error) {
                    console.error('Error switching act:', error);
                }
            }
        }

        // Update all UI elements
        function updateUI() {
            updateSeedInfo();
            updateNeowOptions();
            updateEncounterList();
            updateBossSection();
            resizeCanvas();
        }

        // Update seed info display
        function updateSeedInfo() {
            const container = document.getElementById('seed-info');
            container.innerHTML = `
                <div class="seed-display">${seedData.seed}</div>
                <div class="seed-value">${seedData.seed_value}</div>
                <div class="seed-value" style="color: var(--accent-gold);">Ascension ${seedData.ascension}</div>
            `;
        }

        // Update Neow options (only on Act 1)
        function updateNeowOptions() {
            const section = document.getElementById('neow-section');
            const container = document.getElementById('neow-options');

            // Only show Neow on Act 1
            if (currentAct !== 1) {
                section.style.display = 'none';
                return;
            }
            section.style.display = 'block';

            const options = seedData.neow_options;

            // 2x2 grid for all 4 options (no boss-swap spanning)
            container.innerHTML = options.map(opt => `
                <div class="neow-option" onclick="selectNeowOption('${opt.option}')">
                    <div class="neow-slot">Option ${opt.slot}</div>
                    <div class="neow-name">${opt.name}</div>
                    ${opt.drawback ? `<div class="neow-drawback">${opt.drawback}</div>` : ''}
                </div>
            `).join('');
        }

        // Update encounter list
        function updateEncounterList() {
            const container = document.getElementById('encounter-list');
            const encounters = seedData.encounters;

            let html = '<div class="panel-title">Encounters</div>';

            // Normal encounters
            html += '<div style="margin-bottom: 1rem;">';
            encounters.normal.forEach((enc, idx) => {
                const type = idx < 3 ? 'Weak' : 'Strong';
                html += `
                    <div class="encounter-item">
                        <span class="encounter-idx">${idx + 1}</span>
                        <span class="encounter-name">${enc}</span>
                        <span class="encounter-type">${type}</span>
                    </div>
                `;
            });
            html += '</div>';

            // Elite encounters
            html += '<div class="panel-title" style="margin-top: 1rem;">Elites</div>';
            encounters.elite.slice(0, 5).forEach((enc, idx) => {
                html += `
                    <div class="encounter-item">
                        <span class="encounter-idx">${idx + 1}</span>
                        <span class="encounter-name">${enc}</span>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Update boss section
        function updateBossSection() {
            const container = document.getElementById('boss-section');
            const boss = seedData.boss;

            if (boss && boss.name) {
                container.style.display = 'block';
                container.innerHTML = `
                    <div class="panel-title">Act ${currentAct} Boss</div>
                    <div class="boss-name">${boss.name}</div>
                    <div class="boss-hp">HP: ${boss.a9_hp || boss.hp}</div>
                    <div class="enemy-move" style="margin-top: 0.5rem;">
                        <strong>First Move:</strong> ${boss.move}<br>
                        <em>${boss.details || ''}</em>
                    </div>
                `;
            } else {
                container.style.display = 'none';
            }
        }

        // Draw the map
        function drawMap() {
            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;

            // Clear
            ctx.clearRect(0, 0, width, height);

            if (!seedData || !seedData.map) return;

            const map = seedData.map;
            const nodeRadius = 18;
            const padding = 40;
            const bossY = 16;  // Boss is at y=16 in edges

            const cellWidth = (width - padding * 2) / map.width;
            const cellHeight = (height - padding * 2) / (map.height + 2);  // Extra space for boss

            // Helper to get node position
            function getNodePos(x, y) {
                return {
                    x: padding + x * cellWidth + cellWidth / 2,
                    y: height - padding - y * cellHeight - cellHeight / 2
                };
            }

            // Check if edge is on selected path
            function isEdgeOnPath(edge) {
                for (let i = 0; i < selectedPath.length - 1; i++) {
                    if (selectedPath[i].x === edge.src_x && selectedPath[i].y === edge.src_y &&
                        selectedPath[i+1].x === edge.dst_x && selectedPath[i+1].y === edge.dst_y) {
                        return true;
                    }
                }
                // Check boss edge
                if (selectedPath.length > 0) {
                    const last = selectedPath[selectedPath.length - 1];
                    if (edge.is_boss && edge.src_x === last.x && edge.src_y === last.y) {
                        return true;
                    }
                }
                return false;
            }

            // Check if node is on selected path
            function isNodeOnPath(x, y) {
                return selectedPath.some(p => p.x === x && p.y === y);
            }

            // Draw edges first (non-path)
            map.edges.forEach(edge => {
                if (isEdgeOnPath(edge)) return;  // Draw path edges later

                const src = getNodePos(edge.src_x, edge.src_y);
                let dst;
                if (edge.is_boss) {
                    dst = getNodePos(3, bossY);  // Boss at center top
                } else {
                    dst = getNodePos(edge.dst_x, edge.dst_y);
                }

                ctx.strokeStyle = 'rgba(212, 168, 87, 0.2)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(src.x, src.y);
                ctx.lineTo(dst.x, dst.y);
                ctx.stroke();
            });

            // Draw path edges (highlighted)
            map.edges.forEach(edge => {
                if (!isEdgeOnPath(edge)) return;

                const src = getNodePos(edge.src_x, edge.src_y);
                let dst;
                if (edge.is_boss) {
                    dst = getNodePos(3, bossY);
                } else {
                    dst = getNodePos(edge.dst_x, edge.dst_y);
                }

                // Glow effect for path
                ctx.strokeStyle = 'rgba(212, 168, 87, 0.6)';
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(src.x, src.y);
                ctx.lineTo(dst.x, dst.y);
                ctx.stroke();

                ctx.strokeStyle = '#d4a857';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(src.x, src.y);
                ctx.lineTo(dst.x, dst.y);
                ctx.stroke();
            });

            // Draw nodes
            map.nodes.forEach(node => {
                if (!node.type && !node.has_edges) return;

                const pos = getNodePos(node.x, node.y);
                const color = ROOM_COLORS[node.type] || '#3a3a4a';
                const symbol = ROOM_SYMBOLS[node.type] || '';
                const onPath = isNodeOnPath(node.x, node.y);

                // Glow effect (stronger if on path)
                const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, nodeRadius * 1.5);
                gradient.addColorStop(0, onPath ? color + '80' : color + '40');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, nodeRadius * 1.5, 0, Math.PI * 2);
                ctx.fill();

                // Node circle
                ctx.fillStyle = onPath ? color + '30' : '#1a1a25';
                ctx.strokeStyle = color;
                ctx.lineWidth = onPath ? 3 : 2;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, nodeRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Path order number
                if (onPath) {
                    const pathIdx = selectedPath.findIndex(p => p.x === node.x && p.y === node.y);
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 10px Cinzel, serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText((pathIdx + 1).toString(), pos.x, pos.y - nodeRadius - 8);
                }

                // Symbol
                ctx.fillStyle = color;
                ctx.font = '600 14px Cinzel, serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, pos.x, pos.y + 1);

                // Store node data for click detection
                node._pos = pos;
                node._radius = nodeRadius;
            });

            // Draw boss node at top
            const bossPos = getNodePos(3, bossY);
            const bossColor = ROOM_COLORS['BOSS'];
            const bossOnPath = selectedPath.length > 0 && selectedPath[selectedPath.length - 1].y === 14;

            ctx.fillStyle = bossOnPath ? bossColor + '30' : '#1a1a25';
            ctx.strokeStyle = bossColor;
            ctx.lineWidth = bossOnPath ? 4 : 3;
            ctx.beginPath();
            ctx.arc(bossPos.x, bossPos.y, nodeRadius * 1.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = bossColor;
            ctx.font = '700 16px Cinzel, serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('B', bossPos.x, bossPos.y + 1);

            // Store boss for click detection
            seedData.map._bossPos = bossPos;
            seedData.map._bossRadius = nodeRadius * 1.3;
        }

        // Check if node can be added to path
        function canAddToPath(node) {
            if (selectedPath.length === 0) {
                // First node must be on floor 0
                return node.y === 0;
            }
            const lastNode = selectedPath[selectedPath.length - 1];
            // Check if there's an edge from last node to this node
            return seedData.map.edges.some(e =>
                e.src_x === lastNode.x && e.src_y === lastNode.y &&
                e.dst_x === node.x && e.dst_y === node.y
            );
        }

        // Handle canvas click for path building
        canvas.addEventListener('click', async (e) => {
            if (!seedData || !seedData.map) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Find clicked node
            for (const node of seedData.map.nodes) {
                if (!node._pos) continue;
                const dx = x - node._pos.x;
                const dy = y - node._pos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist <= node._radius + 5) {
                    // Check if already on path
                    const pathIdx = selectedPath.findIndex(p => p.x === node.x && p.y === node.y);

                    if (pathIdx >= 0) {
                        // Remove this node and all after it
                        selectedPath = selectedPath.slice(0, pathIdx);
                        recalculatePathEncounters();
                    } else if (canAddToPath(node)) {
                        // Add to path
                        selectedPath.push({ x: node.x, y: node.y, type: node.type });
                        recalculatePathEncounters();
                    }

                    drawMap();
                    updatePathDisplay();
                    return;
                }
            }
        });

        // Clear path button
        function clearPath() {
            selectedPath = [];
            pathEncounters = { normal: 0, elite: 0 };
            drawMap();
            updatePathDisplay();
        }

        // Recalculate encounter indices along path
        function recalculatePathEncounters() {
            pathEncounters = { normal: 0, elite: 0 };
            selectedPath.forEach(p => {
                if (p.type === 'MONSTER') pathEncounters.normal++;
                if (p.type === 'ELITE') pathEncounters.elite++;
            });
        }

        // Fetch ? room predictions for current path
        async function fetchEventPredictions() {
            if (selectedPath.length === 0 || !currentSeed) {
                eventPredictions = {};
                return;
            }

            try {
                const response = await fetch(`/api/path/${currentSeed}?act=${currentAct}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: selectedPath })
                });
                const data = await response.json();
                eventPredictions = data.event_predictions || {};
            } catch (error) {
                console.error('Error fetching event predictions:', error);
                eventPredictions = {};
            }
        }

        // Update path display in side panel
        async function updatePathDisplay() {
            const container = document.getElementById('floor-details');
            if (selectedPath.length === 0) {
                eventPredictions = {};
                container.innerHTML = `
                    <div class="empty-state">
                        <h3>Click nodes to build a path</h3>
                        <p>Start from floor 0 and trace your route</p>
                    </div>
                `;
                container.style.display = 'block';
                return;
            }

            // Fetch predictions first
            await fetchEventPredictions();

            let html = `
                <div class="floor-details">
                    <div class="floor-header">
                        <div class="floor-number" style="font-size: 1rem;">Path</div>
                        <button class="btn" style="padding: 0.3rem 0.6rem; font-size: 0.7rem;" onclick="clearPath()">Clear</button>
                    </div>
                    <div class="path-sequence">
            `;

            let normalIdx = 0;
            let eliteIdx = 0;

            selectedPath.forEach((p, i) => {
                const encounters = seedData.encounters;
                let encounter = '';
                let symbol = ROOM_SYMBOLS[p.type] || '?';
                let color = ROOM_COLORS[p.type] || '#3d5a80';

                if (p.type === 'MONSTER') {
                    encounter = encounters.normal[normalIdx] || 'Unknown';
                    normalIdx++;
                } else if (p.type === 'ELITE') {
                    encounter = encounters.elite[eliteIdx] || 'Unknown';
                    eliteIdx++;
                } else if (p.type === 'REST') {
                    encounter = 'Rest Site';
                } else if (p.type === 'SHOP') {
                    encounter = 'Shop';
                } else if (p.type === 'TREASURE') {
                    encounter = 'Treasure';
                } else if (p.type === 'EVENT') {
                    // Look up prediction for this ? room
                    const key = `${p.x},${p.y}`;
                    const pred = eventPredictions[key];
                    if (pred) {
                        const outcome = pred.outcome;
                        if (outcome === 'EVENT') {
                            encounter = pred.event_name || 'Event';
                            symbol = 'ðŸ“œ';
                        } else if (outcome === 'MONSTER') {
                            // Use actual encounter from queue
                            encounter = encounters.normal[normalIdx] || 'Combat';
                            normalIdx++;
                            symbol = 'M';
                            color = ROOM_COLORS['MONSTER'];
                        } else if (outcome === 'ELITE') {
                            // Use actual encounter from queue
                            encounter = encounters.elite[eliteIdx] || 'Elite';
                            eliteIdx++;
                            symbol = 'E';
                            color = ROOM_COLORS['ELITE'];
                        } else if (outcome === 'SHOP') {
                            encounter = 'Shop';
                            symbol = '$';
                            color = ROOM_COLORS['SHOP'];
                        } else if (outcome === 'TREASURE') {
                            encounter = 'Treasure';
                            symbol = 'T';
                            color = ROOM_COLORS['TREASURE'];
                        }
                    } else {
                        encounter = '? Unknown';
                    }
                }

                html += `
                    <div class="path-step" style="display: flex; align-items: center; gap: 0.5rem; padding: 0.4rem 0; border-bottom: 1px solid rgba(255,255,255,0.05);">
                        <span style="color: ${color}; font-weight: bold; min-width: 1.5rem;">${i + 1}</span>
                        <span style="color: ${color}; min-width: 1.2rem;">${symbol}</span>
                        <span style="flex: 1;">${encounter}</span>
                        <span style="color: var(--text-muted); font-size: 0.8rem;">F${p.y + 1}</span>
                    </div>
                `;
            });

            html += `</div></div>`;
            container.innerHTML = html;
            container.style.display = 'block';
        }

        // Show floor details
        async function showFloorDetails(node) {
            const container = document.getElementById('floor-details');
            const floor = node.y + 1;
            const roomType = node.type || 'EVENT';

            // Determine encounter index
            let encounterIdx = 0;
            if (roomType === 'MONSTER') {
                encounterIdx = normalEncounterIdx;
            } else if (roomType === 'ELITE') {
                encounterIdx = eliteEncounterIdx;
            }

            try {
                const response = await fetch(
                    `/api/floor/${currentSeed}/${floor}?act=${currentAct}&type=${roomType}&idx=${encounterIdx}&ascension=${currentAscension}`
                );
                const data = await response.json();

                let html = `
                    <div class="floor-details">
                        <div class="floor-header">
                            <div class="floor-number">${floor}</div>
                            <div class="room-type ${roomType.toLowerCase()}">${roomType}</div>
                        </div>
                `;

                if (data.enemy) {
                    html += `
                        <div class="enemy-info">
                            <div class="enemy-name">${data.enemy}</div>
                            ${data.hp ? `<div class="enemy-hp">HP: ${data.hp}</div>` : ''}
                            ${data.first_move ? `
                                <div class="enemy-move">
                                    <strong>${data.first_move.move}</strong>
                                    ${data.first_move.damage ? `(${data.first_move.damage} dmg)` : ''}
                                    ${data.first_move.details ? `<br><em>${data.first_move.details}</em>` : ''}
                                </div>
                            ` : ''}
                        </div>
                    `;
                }

                if (data.gold || data.cards || data.potion || data.relic) {
                    html += '<div class="rewards-section">';

                    if (data.gold) {
                        html += `
                            <div class="reward-row">
                                <span class="reward-label">Gold</span>
                                <span class="reward-value">${data.gold}</span>
                            </div>
                        `;
                    }

                    if (data.cards) {
                        html += `
                            <div class="reward-row">
                                <span class="reward-label">Cards</span>
                                <span class="reward-value">
                                    ${data.cards.map(c =>
                                        `<span class="card-reward ${c.rarity.toLowerCase()}">${c.name}${c.upgraded ? '+' : ''}</span>`
                                    ).join('')}
                                </span>
                            </div>
                        `;
                    }

                    if (data.potion) {
                        html += `
                            <div class="reward-row">
                                <span class="reward-label">Potion</span>
                                <span class="reward-value">${data.potion.name}</span>
                            </div>
                        `;
                    }

                    if (data.relic) {
                        html += `
                            <div class="reward-row">
                                <span class="reward-label">Relic</span>
                                <span class="reward-value">${data.relic.name}</span>
                            </div>
                        `;
                    }

                    html += '</div>';
                }

                if (data.note) {
                    html += `<div class="reward-row"><em style="color: var(--text-muted);">${data.note}</em></div>`;
                }

                if (data.shop) {
                    html += `
                        <div class="rewards-section">
                            <div class="reward-row"><strong>Shop Contents:</strong></div>
                            <div class="reward-row">
                                <span class="reward-label">Cards</span>
                                <span class="reward-value" style="font-size: 0.8rem;">
                                    ${data.shop.cards.map(c => `${c[0]} (${c[1]}g)`).join(', ')}
                                </span>
                            </div>
                            <div class="reward-row">
                                <span class="reward-label">Relics</span>
                                <span class="reward-value" style="font-size: 0.8rem;">
                                    ${data.shop.relics.map(r => `${r[0]} (${r[1]}g)`).join(', ')}
                                </span>
                            </div>
                        </div>
                    `;
                }

                html += '</div>';

                container.innerHTML = html;
                container.style.display = 'block';
            } catch (error) {
                console.error('Error loading floor details:', error);
            }
        }

        function selectNeowOption(option) {
            console.log('Selected Neow option:', option);
            // Could trigger recalculation based on Neow choice
        }

        // Initial load
        document.addEventListener('DOMContentLoaded', () => {
            resizeCanvas();
            loadSeed();
        });

        // Handle enter key on seed input
        document.getElementById('seed-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') loadSeed();
        });
    </script>
</body>
</html>
